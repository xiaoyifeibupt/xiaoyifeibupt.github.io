<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>从零开始实现自己的httpd——epoll | xiaoyifeibupt&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始实现自己的httpd——epoll">
<meta property="og:url" content="http://xiaoyifeibupt.github.io/2014/12/21/2014-12-21-xhttpd-epoll/index.html">
<meta property="og:site_name" content="xiaoyifeibupt's blog">
<meta property="og:description" content="epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水">
<meta property="og:updated_time" content="2016-05-28T05:51:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从零开始实现自己的httpd——epoll">
<meta name="twitter:description" content="epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水">
  
    <link rel="alternative" href="/atom.xml" title="xiaoyifeibupt&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/face.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">xiaoyifeibupt</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">博客首页</a></li>
                        
                            <li><a href="/tags">分类标签</a></li>
                        
                            <li><a href="/about">关于</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:xiaoyifeibupt@163.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/xiaoyifeibupt" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-yifei" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="http://weibo.com/yifeixiao/" title="weibo">weibo</a>
                            
                                <a class="fl facebook" target="_blank" href="https://www.facebook.com/profile.php?id=100011123822524" title="facebook">facebook</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/Design-pattern/" style="font-size: 17.5px;">Design-pattern</a> <a href="/tags/LaTex/" style="font-size: 10px;">LaTex</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/算法/" style="font-size: 12.5px;">算法</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">xiaoyifeibupt</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/face.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">xiaoyifeibupt</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">博客首页</a></li>
                
                    <li><a href="/tags">分类标签</a></li>
                
                    <li><a href="/about">关于</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:xiaoyifeibupt@163.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/xiaoyifeibupt" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/xiao-yifei" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="http://weibo.com/yifeixiao/" title="weibo">weibo</a>
                    
                        <a class="facebook" target="_blank" href="https://www.facebook.com/profile.php?id=100011123822524" title="facebook">facebook</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-2014-12-21-xhttpd-epoll" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/21/2014-12-21-xhttpd-epoll/" class="article-date">
      <time datetime="2014-12-21T05:18:08.000Z" itemprop="datePublished">2014-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      从零开始实现自己的httpd——epoll
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/UNIX系统/">UNIX系统</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
<a id="more"></a>
<h2 id="epoll系统调用。"><a href="#epoll系统调用。" class="headerlink" title="epoll系统调用。"></a>epoll系统调用。</h2><p><strong><code>int epoll_create(int size);</code></strong></p>
<p>创建一个epoll的句柄。自从linux2.6.8之后，size参数是被忽略的。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p><strong><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></strong></p>
<p>epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p>
<ul>
<li>第一个参数是epoll_create()的返回值。</li>
<li><p>第二个参数表示动作，用三个宏来表示：</p>
<p>   EPOLL_CTL_ADD：注册新的fd到epfd中；<br>   EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>   EPOLL_CTL_DEL：从epfd中删除一个fd；</p>
</li>
<li><p>第三个参数是需要监听的fd。</p>
</li>
<li>第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存触发事件的某个文件描述符相关的数据（与具体使用方式有关）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"> <span class="comment">//感兴趣的事件和被触发的事件</span></span><br><span class="line"><span class="keyword">struct</span> epoll_event &#123;</span><br><span class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<p><strong><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code></strong></p>
<p>收集在epoll监控的事件中已经发送的事件。参数events是分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存）。maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时。</p>
<h2 id="epoll工作原理"><a href="#epoll工作原理" class="headerlink" title="epoll工作原理"></a>epoll工作原理</h2><p>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。</p>
<p>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p>
<h2 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h2><p>水平触发（LT）和边缘触发（ET）假如有这样一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li>
<li>这个时候从管道的另一端被写入了2KB的数据</li>
<li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了1KB的数据</li>
<li>调用epoll_wait(2)……</li>
</ol>
<h3 id="Edge-Triggered-工作模式："><a href="#Edge-Triggered-工作模式：" class="headerlink" title="Edge Triggered 工作模式："></a>Edge Triggered 工作模式：</h3><p>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。在上面的例子中，会有一个事件产生在RFD句柄上，因为在第2步执行了一个写操作，然后，事件将会在第3步被销毁。因为第4步的读取操作没有读空文件输入缓冲区内的数据，因此我们在第5步调用 epoll_wait(2)完成后，是否挂起是不确定的。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。</p>
<ul>
<li>基于非阻塞文件句柄</li>
<li>只有当read(2)或者write(2)返回EAGAIN时才需要挂起，等待。但这并不是说每次read()时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read()返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</li>
</ul>
<h3 id="Level-Triggered-工作模式"><a href="#Level-Triggered-工作模式" class="headerlink" title="Level Triggered 工作模式"></a>Level Triggered 工作模式</h3><p>相反的，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll(2)，并且无论后面的数据是否被使用，因此他们具有同样的职能。因为即使使用ET模式的epoll，在收到多个chunk的数据的时候仍然会产生多个事件。调用者可以设定EPOLLONESHOT标志，在 epoll_wait(2)收到事件后epoll会与事件关联的文件句柄从epoll描述符中禁止掉。因此当EPOLLONESHOT设定后，使用带有 EPOLL_CTL_MOD标志的epoll_ctl(2)处理文件句柄就成为调用者必须作的事情。</p>
<h3 id="LT和ET的比较"><a href="#LT和ET的比较" class="headerlink" title="LT和ET的比较"></a>LT和ET的比较</h3><p>LT(level triggered)是epoll缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你 的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表．</p>
<p>ET (edge-triggered)是高速工作方式，只支持no-block socket，它效率要比LT更高。ET与LT的区别在于，当一个新的事件到来时，ET模式下当然可以从epoll_wait调用中获取到这个事件，可是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字中没有新的事件再次到来时，在ET模式下是无法再次从epoll_wait调用中获取这个事件的。而LT模式正好相反，只要一个事件对应的套接字缓冲区还有数据，就总能从epoll_wait中获取这个事件。<br>因此，LT模式下开发基于epoll的应用要简单些，不太容易出错。而在ET模式下事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应。</p>
<h2 id="epoll的优点："><a href="#epoll的优点：" class="headerlink" title="epoll的优点："></a>epoll的优点：</h2><p>1.支持一个进程打开大数目的socket描述符(FD)</p>
<p>select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>
<p>2.IO效率不随FD数目增加而线性下降</p>
<p>传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p>
<p>3.使用mmap加速内核与用户空间的消息传递</p>
<p>这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的。</p>
<p>4.内核微调</p>
<p>这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小— 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网卡驱动架构。</p>
<p><strong>linux下epoll如何实现高效处理百万句柄的</strong></p>
<p>开发高性能网络程序时，windows开发者们言必称iocp，linux开发者们则言必称epoll。大家都明白epoll是一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄，比起以前的select和poll效率高大发了。我们用起epoll来都感觉挺爽，确实快，那么，它到底为什么可以高速处理这么多并发连接呢？</p>
<p>使用起来很清晰，首先要调用epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</p>
<p>epoll_ctl可以操作上面建立的epoll，例如，将刚建立的socket加入到epoll中让其监控，或者把 epoll正在监控的某个socket句柄移出epoll，不再监控它等等。</p>
<p>epoll_wait在调用时，在给定的timeout时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程。</p>
<p>从上面的调用方式就可以看到epoll比select/poll的优越之处：因为后者每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态，如果以万计的句柄会导致每次都要copy几十几百KB的内存到内核态，非常低效。而我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</p>
<p>所以，实际上在你调用epoll_create后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用epoll_ctl只是在往内核的数据结构里塞入新的socket句柄。<br> 当一个进程调用epoll_creaqte方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"></span><br><span class="line">171 * This structure is stored inside the "private_data" member of the file</span><br><span class="line"></span><br><span class="line">172 * structure and represents the main data structure for the eventpoll</span><br><span class="line"></span><br><span class="line">173 * interface.</span><br><span class="line"></span><br><span class="line">174 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">175</span><span class="keyword">struct</span> eventpoll &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">176</span>        <span class="comment">/* Protect the access to this structure */</span></span><br><span class="line"></span><br><span class="line"><span class="number">177</span>        <span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="number">178</span></span><br><span class="line"></span><br><span class="line"><span class="number">179</span>        <span class="comment">/*</span><br><span class="line"></span><br><span class="line">180         * This mutex is used to ensure that files are not removed</span><br><span class="line"></span><br><span class="line">181         * while epoll is using them. This is held during the event</span><br><span class="line"></span><br><span class="line">182         * collection loop, the file cleanup path, the epoll file exit</span><br><span class="line"></span><br><span class="line">183         * code and the ctl operations.</span><br><span class="line"></span><br><span class="line">184         */</span></span><br><span class="line"></span><br><span class="line"><span class="number">185</span>        <span class="keyword">struct</span> mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="number">186</span></span><br><span class="line"></span><br><span class="line"><span class="number">187</span>        <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line"></span><br><span class="line"><span class="number">188</span>        <span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line"><span class="number">189</span></span><br><span class="line"></span><br><span class="line"><span class="number">190</span>        <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line"></span><br><span class="line"><span class="number">191</span>        <span class="keyword">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line"><span class="number">192</span></span><br><span class="line"></span><br><span class="line"><span class="number">193</span>        <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line"></span><br><span class="line"><span class="number">194</span>        <span class="keyword">struct</span> list_head rdllist;</span><br><span class="line"></span><br><span class="line"><span class="number">195</span></span><br><span class="line"></span><br><span class="line"><span class="number">196</span>        <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line"></span><br><span class="line"><span class="number">197</span>        <span class="keyword">struct</span> rb_root rbr;<span class="comment">//红黑树根节点，这棵树存储着所有添加到epoll中的事件，也就是这个epoll监控的事件</span></span><br><span class="line"><span class="number">198</span></span><br><span class="line"><span class="number">199</span>        <span class="comment">/*</span><br><span class="line">200         * This is a single linked list that chains all the "struct epitem" that</span><br><span class="line">201         * happened while transferring ready events to userspace w/out</span><br><span class="line">202         * holding -&gt;lock.</span><br><span class="line">203         */</span></span><br><span class="line"><span class="number">204</span>        <span class="keyword">struct</span> epitem *ovflist;</span><br><span class="line"><span class="number">205</span></span><br><span class="line"><span class="number">206</span>        <span class="comment">/* wakeup_source used when ep_scan_ready_list is running */</span></span><br><span class="line"><span class="number">207</span>        <span class="keyword">struct</span> wakeup_source *ws;</span><br><span class="line"><span class="number">208</span></span><br><span class="line"><span class="number">209</span>        <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line"><span class="number">210</span>        <span class="keyword">struct</span> user_struct *user;</span><br><span class="line"><span class="number">211</span></span><br><span class="line"><span class="number">212</span>        <span class="keyword">struct</span> file *file;</span><br><span class="line"><span class="number">213</span></span><br><span class="line"><span class="number">214</span>        <span class="comment">/* used to optimize loop detection check */</span></span><br><span class="line"><span class="number">215</span>        <span class="keyword">int</span> visited;</span><br><span class="line"><span class="number">216</span>        <span class="keyword">struct</span> list_head visited_list_link;<span class="comment">//双向链表中保存着将要通过epoll_wait返回给用户的、满足条件的事件</span></span><br><span class="line"><span class="number">217</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个epoll对象都有一个独立的eventpoll结构体，这个结构体会在内核空间中创造独立的内存，用于存储使用epoll_ctl方法向epoll对象中添加进来的事件。这样，重复的事件就可以通过红黑树而高效的识别出来。<br>在epoll中，对于每一个事件都会建立一个epitem结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 130 * Each file descriptor added to the eventpoll interface will</span><br><span class="line"> 131 * have an entry of this type linked to the "rbr" RB tree.</span><br><span class="line"> 132 * Avoid increasing the size of this struct, there can be many thousands</span><br><span class="line"> 133 * of these on a server and we do not want this to take another cache line.</span><br><span class="line"> 134 */</span></span><br><span class="line"> <span class="number">135</span><span class="keyword">struct</span> epitem &#123;</span><br><span class="line"> <span class="number">136</span>        <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line"> <span class="number">137</span>        <span class="keyword">struct</span> rb_node rbn;</span><br><span class="line"> <span class="number">138</span></span><br><span class="line"> <span class="number">139</span>        <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line"> <span class="number">140</span>        <span class="keyword">struct</span> list_head rdllink;</span><br><span class="line"> <span class="number">141</span></span><br><span class="line"> <span class="number">142</span>        <span class="comment">/*</span><br><span class="line"> 143         * Works together "struct eventpoll"-&gt;ovflist in keeping the</span><br><span class="line"> 144         * single linked chain of items.</span><br><span class="line"> 145         */</span></span><br><span class="line"> <span class="number">146</span>        <span class="keyword">struct</span> epitem *next;</span><br><span class="line"> <span class="number">147</span></span><br><span class="line"> <span class="number">148</span>        <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line"> <span class="number">149</span>        <span class="keyword">struct</span> epoll_filefd ffd;</span><br><span class="line"> <span class="number">150</span></span><br><span class="line"> <span class="number">151</span>        <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line"> <span class="number">152</span>        <span class="keyword">int</span> nwait;</span><br><span class="line"> <span class="number">153</span></span><br><span class="line"> <span class="number">154</span>        <span class="comment">/* List containing poll wait queues */</span></span><br><span class="line"> <span class="number">155</span>        <span class="keyword">struct</span> list_head pwqlist;</span><br><span class="line"> <span class="number">156</span></span><br><span class="line"> <span class="number">157</span>        <span class="comment">/* The "container" of this item */</span></span><br><span class="line"> <span class="number">158</span>        <span class="keyword">struct</span> eventpoll *ep;</span><br><span class="line"> <span class="number">159</span></span><br><span class="line"> <span class="number">160</span>        <span class="comment">/* List header used to link this item to the "struct file" items list */</span></span><br><span class="line"> <span class="number">161</span>        <span class="keyword">struct</span> list_head fllink;</span><br><span class="line"> <span class="number">162</span></span><br><span class="line"> <span class="number">163</span>        <span class="comment">/* wakeup_source used when EPOLLWAKEUP is set */</span></span><br><span class="line"> <span class="number">164</span>        <span class="keyword">struct</span> wakeup_source __rcu *ws;</span><br><span class="line"> <span class="number">165</span></span><br><span class="line"> <span class="number">166</span>        <span class="comment">/* The structure that describe the interested events and the source fd */</span></span><br><span class="line"> <span class="number">167</span>        <span class="keyword">struct</span> epoll_event event;</span><br><span class="line"> <span class="number">168</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>此外，epoll还维护了一个双链表，用户存储发生的事件。当epoll_wait调用时，仅仅观察这个list链表里有没有数据即eptime项即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p>
<p>而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已，如何能不高效？！</p>
<p>那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p>
<p>如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p>
<h2 id="epoll的使用方法"><a href="#epoll的使用方法" class="headerlink" title="epoll的使用方法"></a>epoll的使用方法</h2><p>通过在包含一个头文件#include <sys epoll.h=""> 以及几个简单的API将可以大大的提高你的网络服务器的支持人数。</sys></p>
<p>首先通过create_epoll(int maxfds)来创建一个epoll的句柄。这个函数会返回一个新的epoll句柄，之后的所有操作将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。</p>
<p>之后在你的网络主循环里面，每一帧的调用epoll_wait(int epfd, epoll_event events, int max events, int timeout)来查询所有的网络接口，看哪一个可以读，哪一个可以写了。基本的语法为：</p>
<pre><code>nfds = epoll_wait(kdpfd, events, maxevents, -1);
</code></pre><p>其中kdpfd为用epoll_create创建之后的句柄，events是一个epoll_event*的指针，当epoll_wait这个函数操作成功之后，epoll_events里面将储存所有的读写事件。max_events是当前需要监听的所有socket句柄数。最后一个timeout是 epoll_wait的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，直到有事件返回，为任意正整数的时候表示等这么长的时间，如果一直没有事件，则返回。一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率。</p>
<p>epoll_wait返回之后应该是一个循环，遍历所有的事件。</p>
<p>几乎所有的epoll程序都使用下面的框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">    nfds = epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">            ev.data.fd=connfd;</span><br><span class="line">            ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">            epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">        &#123;</span><br><span class="line">            n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">            ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">            ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">            epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">            sockfd = md-&gt;fd;</span><br><span class="line">            send( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="keyword">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">            ev.data.fd=sockfd;</span><br><span class="line">            ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">            epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数:</span></span><br><span class="line"><span class="comment">//功能:创建和绑定一个TCP socket</span></span><br><span class="line"><span class="comment">//参数:端口</span></span><br><span class="line"><span class="comment">//返回值:创建的socket</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">create_and_bind</span> <span class="params">(<span class="keyword">char</span> *port)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> addrinfo hints;</span><br><span class="line"><span class="keyword">struct</span> addrinfo *result, *rp;</span><br><span class="line"><span class="keyword">int</span> s, sfd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span> (&amp;hints, <span class="number">0</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> addrinfo));</span><br><span class="line">hints.ai_family = AF_UNSPEC;     <span class="comment">/* Return IPv4 and IPv6 choices */</span></span><br><span class="line">hints.ai_socktype = SOCK_STREAM; <span class="comment">/* We want a TCP socket */</span></span><br><span class="line">hints.ai_flags = AI_PASSIVE;     <span class="comment">/* All interfaces */</span></span><br><span class="line"></span><br><span class="line">s = getaddrinfo (<span class="literal">NULL</span>, port, &amp;hints, &amp;result);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"getaddrinfo: %s\n"</span>, gai_strerror (s));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (rp = result; rp != <span class="literal">NULL</span>; rp = rp-&gt;ai_next)</span><br><span class="line">&#123;</span><br><span class="line">  sfd = socket (rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);</span><br><span class="line">  <span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  s = bind (sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We managed to bind successfully! */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  close (sfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"Could not bind\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">freeaddrinfo (result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="comment">//功能:设置socket为非阻塞的</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">make_socket_non_blocking</span> <span class="params">(<span class="keyword">int</span> sfd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flags, s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到文件状态标志</span></span><br><span class="line">flags = fcntl (sfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (flags == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror (<span class="string">"fcntl"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文件状态标志</span></span><br><span class="line">flags |= O_NONBLOCK;</span><br><span class="line">s = fcntl (sfd, F_SETFL, flags);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror (<span class="string">"fcntl"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//端口由参数argv[1]指定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sfd, s;</span><br><span class="line"><span class="keyword">int</span> efd;</span><br><span class="line"><span class="keyword">struct</span> epoll_event event;</span><br><span class="line"><span class="keyword">struct</span> epoll_event *events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"Usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">exit</span> (EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sfd = create_and_bind (argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (sfd == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">s = make_socket_non_blocking (sfd);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">s = listen (sfd, SOMAXCONN);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror (<span class="string">"listen"</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了参数size被忽略外,此函数和epoll_create完全相同</span></span><br><span class="line">efd = epoll_create1 (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror (<span class="string">"epoll_create"</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.data.fd = sfd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;<span class="comment">//读入,边缘触发方式</span></span><br><span class="line">s = epoll_ctl (efd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  perror (<span class="string">"epoll_ctl"</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Buffer where events are returned */</span></span><br><span class="line">events = <span class="built_in">calloc</span> (MAXEVENTS, <span class="keyword">sizeof</span> event);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The event loop */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">  n = epoll_wait (efd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) ||</span><br><span class="line">          (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">          (!(events[i].events &amp; EPOLLIN)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* An error has occured on this fd, or the socket is not</span><br><span class="line">             ready for reading (why were we notified then?) */</span></span><br><span class="line">          <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"epoll error\n"</span>);</span><br><span class="line">          close (events[i].data.fd);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* We have a notification on the listening socket, which</span><br><span class="line">             means one or more incoming connections. */</span></span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">              <span class="keyword">socklen_t</span> in_len;</span><br><span class="line">              <span class="keyword">int</span> infd;</span><br><span class="line">              <span class="keyword">char</span> hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">              in_len = <span class="keyword">sizeof</span> in_addr;</span><br><span class="line">              infd = accept (sfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">              <span class="keyword">if</span> (infd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((errno == EAGAIN) ||</span><br><span class="line">                      (errno == EWOULDBLOCK))</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/* We have processed all incoming</span><br><span class="line">                         connections. */</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      perror (<span class="string">"accept"</span>);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                              <span class="comment">//将地址转化为主机名或者服务名</span></span><br><span class="line">              s = getnameinfo (&amp;in_addr, in_len,</span><br><span class="line">                               hbuf, <span class="keyword">sizeof</span> hbuf,</span><br><span class="line">                               sbuf, <span class="keyword">sizeof</span> sbuf,</span><br><span class="line">                               NI_NUMERICHOST | NI_NUMERICSERV);<span class="comment">//flag参数:以数字名返回</span></span><br><span class="line">                              <span class="comment">//主机地址和服务地址</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">"Accepted connection on descriptor %d "</span></span><br><span class="line">                         <span class="string">"(host=%s, port=%s)\n"</span>, infd, hbuf, sbuf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Make the incoming socket non-blocking and add it to the</span><br><span class="line">                 list of fds to monitor. */</span></span><br><span class="line">              s = make_socket_non_blocking (infd);</span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">abort</span> ();</span><br><span class="line"></span><br><span class="line">              event.data.fd = infd;</span><br><span class="line">              event.events = EPOLLIN | EPOLLET;</span><br><span class="line">              s = epoll_ctl (efd, EPOLL_CTL_ADD, infd, &amp;event);</span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  perror (<span class="string">"epoll_ctl"</span>);</span><br><span class="line">                  <span class="built_in">abort</span> ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* We have data on the fd waiting to be read. Read and</span><br><span class="line">             display it. We must read whatever data is available</span><br><span class="line">             completely, as we are running in edge-triggered mode</span><br><span class="line">             and won't get a notification again for the same</span><br><span class="line">             data. */</span></span><br><span class="line">          <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">ssize_t</span> count;</span><br><span class="line">              <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">              count = read (events[i].data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">              <span class="keyword">if</span> (count == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* If errno == EAGAIN, that means we have read all</span><br><span class="line">                     data. So go back to the main loop. */</span></span><br><span class="line">                  <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">                    &#123;</span><br><span class="line">                      perror (<span class="string">"read"</span>);</span><br><span class="line">                      done = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* End of file. The remote has closed the</span><br><span class="line">                     connection. */</span></span><br><span class="line">                  done = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Write the buffer to standard output */</span></span><br><span class="line">              s = write (<span class="number">1</span>, buf, count);</span><br><span class="line">              <span class="keyword">if</span> (s == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  perror (<span class="string">"write"</span>);</span><br><span class="line">                  <span class="built_in">abort</span> ();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (done)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">printf</span> (<span class="string">"Closed connection on descriptor %d\n"</span>,</span><br><span class="line">                      events[i].data.fd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Closing the descriptor will make epoll remove it</span><br><span class="line">                 from the set of descriptors which are monitored. */</span></span><br><span class="line">              close (events[i].data.fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span> (events);</span><br><span class="line"></span><br><span class="line">close (sfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2014/12/21/2014-12-21-xhttpd-epoll/">从零开始实现自己的httpd——epoll</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 xiaoyifeibupt 的个人博客">xiaoyifeibupt</a></p>
        <p><span>发布时间:</span>2014年12月21日 - 13时18分</p>
        <p><span>最后更新:</span>2016年05月28日 - 13时51分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2014/12/21/2014-12-21-xhttpd-epoll/" title="从零开始实现自己的httpd——epoll">http://xiaoyifeibupt.github.io/2014/12/21/2014-12-21-xhttpd-epoll/</a>
            <span class="copy-path" data-clipboard-text="原文: http://xiaoyifeibupt.github.io/2014/12/21/2014-12-21-xhttpd-epoll/　　作者: xiaoyifeibupt" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2014/12/23/2014-12-23-xhttpd-epollnote/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          从零开始实现自己的httpd——epoll读写数据的注意事项
        
      </div>
    </a>
  
  
    <a href="/2014/12/19/2014-12-19-xhttpd-socket/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">从零开始实现自己的httpd——socket</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll系统调用。"><span class="toc-number">1.</span> <span class="toc-text">epoll系统调用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll工作原理"><span class="toc-number">2.</span> <span class="toc-text">epoll工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll的工作模式"><span class="toc-number">3.</span> <span class="toc-text">epoll的工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Edge-Triggered-工作模式："><span class="toc-number">3.1.</span> <span class="toc-text">Edge Triggered 工作模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Level-Triggered-工作模式"><span class="toc-number">3.2.</span> <span class="toc-text">Level Triggered 工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LT和ET的比较"><span class="toc-number">3.3.</span> <span class="toc-text">LT和ET的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll的优点："><span class="toc-number">4.</span> <span class="toc-text">epoll的优点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll的使用方法"><span class="toc-number">5.</span> <span class="toc-text">epoll的使用方法</span></a></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2014/12/23/2014-12-23-xhttpd-epollnote/" title="上一篇: 从零开始实现自己的httpd——epoll读写数据的注意事项">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2014/12/19/2014-12-19-xhttpd-socket/" title="下一篇: 从零开始实现自己的httpd——socket">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/02/2017-04-02-android_interview/">北邮人论坛DSS886安卓面试总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/15/2016-05-13-Sublime-LaTex-Chinese-support/">部署Mac OS X上的Sublime Text + LaTex中文环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/15/2015-04-15-string-function/">字符串相关库函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/10/2015-04-10-Knuth-Morris-Pratt/">彻底理解KMP算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/06/2015-04-06-tcp-trans/">TCP状态转换</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/01/2015-04-01-C-CPP-polymorphism/">用C实现C++中的多态性</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/22/2015-03-22-cpp-function-call/">C函数调用机制及栈帧指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/19/2015-01-19-effective-cpp-6/">Effective C++ —— 继承与面向对象设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/18/2015-01-18-effective-cpp-5/">Effective C++ —— 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/17/2015-01-17-effective-cpp-4/">Effective C++ —— 设计与声明</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/16/2015-01-16-effective-cpp-3/">Effective C++ —— 资源管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/11/2015-01-11-effective-cpp-2/">Effective C++ —— 构造析构赋值运算</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/09/2015-01-09-effective-cpp-1/">Effective C++ —— 让自己习惯C++</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/29/2014-12-29-xhttpd-makefile/">从零开始实现自己的httpd——Makefile</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/23/2014-12-23-xhttpd-epollnote/">从零开始实现自己的httpd——epoll读写数据的注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/21/2014-12-21-xhttpd-epoll/">从零开始实现自己的httpd——epoll</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/19/2014-12-19-xhttpd-socket/">从零开始实现自己的httpd——socket</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/18/2014-12-18-xhttpd-buffer/">从零开始实现自己的httpd——buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/16/2014-12-16-http- tinyhttpd/">C 语言实现最简单的 HTTP 服务器tinyhttpd详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/15/2014-12-15-http-protocol/">HTTP协议介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/25/2014-11-25-CSAPP-chapter-2/">CSAPP——信息的表示和处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/23/2014-11-23-Design-pattern-Decorator-Memento-State-Visitor-Mediator-Interpreter/">设计模式--备忘录/状态/访问者/中介者/解释器</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/18/2014-11-18-Design-pattern-strategy-Template-Observer-Iterator-ChainofResponsibility-Command/">设计模式--策略/模板方法/观察者/迭代子/责任链/命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/15/2014-11-15-Design-pattern-Decorator-Proxy-Facade-Bridge-Composite-Flyweight/">设计模式--装饰/代理/外观/桥接/组合/享元</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/12/2014-11-12-Design-pattern-Adapter/">设计模式--适配器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/10/2014-11-10-Design-pattern-Builder/">设计模式--建造者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/09/2014-11-09-Design-pattern-Prototype/">设计模式--原型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/08/2014-11-08-Design-pattern-Singleton/">设计模式--单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/07/2014-11-07-Design-pattern-Abstract-Factory/">设计模式--抽象工厂模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/05/2014-11-05-Design-pattern-Factory-Method/">设计模式--工程模式</a></li></ul>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 xiaoyifeibupt
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
    </div>
</footer>

    </div>
    <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>