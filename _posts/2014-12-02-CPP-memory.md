---
layout: post
title:  C/C++变量在内存中的分布
categories: [CPP]
---

C语言中内存分布及程序运行中(BSS段、数据段、代码段、堆栈）

BSS段:（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。
BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

数据段 ：数据段（data segment）通常是指用来存放程序中 已初始化 的 全局变量 的一块内存区域。数据段属于静态内存分配。

代码段： 代码段（code segment/text segment）通常是指用来存放 程序执行代码 的一块内存区域。
这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于 只读 , 某些架构也允许代码段为可写，即允许修改程序。
在代码段中，也有可能包含一些 只读的常数变量 ，例如字符串常量等。程序段为程序代码在内存中的映射.一个程序可以在内存中多有个副本.

堆（heap） ：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被剔除（堆被缩减）

栈(stack) ：栈又称堆栈， 存放程序的 局部变量 （但不包括static声明的变量， static 意味着 在数据段中 存放变量）。
除此以外，在函数被调用时，栈用来传递参数和返回值。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。
储动态内存分配,需要程序员手工分配,手工释放

C内存空间分布图

                                  高位地址   命令行参数和环境变量
                                                      栈
                                                      
                                                      
                                                      堆
                                            未初始化数据（由exec初始化为0）
                                            初始化数据（由exec从程序中读入）
                                  低位地址     正文（由exec从程序中读入）
                                              

用程序验证一下：

```C
#include <stdio.h>
#include <malloc.h>
int g_i = 100;
int g_j = 200;
int g_k, g_h;
int main()
{
	const int MAXN = 100;
	int *p = (int*)malloc(MAXN * sizeof(int));
	static int s_i = 5;
	static int s_j = 10;
	static int s_k;
	static int s_h;
	int i = 5;
	int j = 10;
	int k = 20;
	int f, h;
	char *pstr1 = "MoreWindows123456789";
	char *pstr2 = "MoreWindows123456789";
	char *pstr3 = "Hello";
	
	
	printf("堆中数据地址：0x%08x\n", p);
	
	putchar('\n');
	printf("栈中数据地址(有初值)：0x%08x = %d\n", &i, i);
	printf("栈中数据地址(有初值)：0x%08x = %d\n", &j, j);
	printf("栈中数据地址(有初值)：0x%08x = %d\n", &k, k);
	printf("栈中数据地址(无初值)：0x%08x = %d\n", &f, f);
	printf("栈中数据地址(无初值)：0x%08x = %d\n", &h, h);
	
	putchar('\n');
	printf("静态数据地址(有初值)：0x%08x = %d\n", &s_i, s_i);
	printf("静态数据地址(有初值)：0x%08x = %d\n", &s_j, s_j);
	printf("静态数据地址(无初值)：0x%08x = %d\n", &s_k, s_k);
	printf("静态数据地址(无初值)：0x%08x = %d\n", &s_h, s_h);
	
	putchar('\n');
	printf("全局数据地址(有初值)：0x%08x = %d\n", &g_i, g_i);
	printf("全局数据地址(有初值)：0x%08x = %d\n", &g_j, g_j);
	printf("全局数据地址(无初值)：0x%08x = %d\n", &g_k, g_k);
	printf("全局数据地址(无初值)：0x%08x = %d\n", &g_h, g_h);
	
	putchar('\n');
	printf("字符串常量数据地址：0x%08x 指向 0x%08x 内容为-%s\n", &pstr1, pstr1, pstr1);
	printf("字符串常量数据地址：0x%08x 指向 0x%08x 内容为-%s\n", &pstr2, pstr2, pstr2);
	printf("字符串常量数据地址：0x%08x 指向 0x%08x 内容为-%s\n", &pstr3, pstr3, pstr3);
	free(p);
	return 0;
}
```

运行结果：

`
堆中数据地址：0x09f04008

栈中数据地址(有初值)：0xbf984e34 = 5
栈中数据地址(有初值)：0xbf984e30 = 10
栈中数据地址(有初值)：0xbf984e2c = 20
栈中数据地址(无初值)：0xbf984e28 = 6884576
栈中数据地址(无初值)：0xbf984e24 = 134513259

静态数据地址(有初值)：0x08049b10 = 5
静态数据地址(有初值)：0x08049b14 = 10
静态数据地址(无初值)：0x08049b20 = 0
静态数据地址(无初值)：0x08049b24 = 0

全局数据地址(有初值)：0x08049b08 = 100
全局数据地址(有初值)：0x08049b0c = 200
全局数据地址(无初值)：0x08049b2c = 0
全局数据地址(无初值)：0x08049b28 = 0

字符串常量数据地址：0xbf984e20 指向 0x080487c4 内容为-MoreWindows123456789
字符串常量数据地址：0xbf984e1c 指向 0x080487c4 内容为-MoreWindows123456789
字符串常量数据地址：0xbf984e18 指向 0x080487d9 内容为-Hello
`


可以看出：

1.变量在内存地址的分布为：堆-栈-代码区-全局静态-常量数据

2.同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间（只有未赋值的全局变量是个例外）。

3.全局变量和静态变量如果不赋值，默认为0。 栈中的变量如果不赋值，则是一个随机的数据。

4.编译器会认为全局变量和静态变量是等同的，已初始化的全局变量和静态变量分配在一起，未初始化的全局变量和静态变量分配在另一起。

 

上面程序全在一个主函数中，下面增加函数调用，看看函数的参数和函数中变量会分配在什么地方。

程序如下：

```C
#include <stdio.h>
void fun(int i)
{
	int j = i;
	static int s_i = 100;
	static int s_j;

	printf("子函数的参数:        0x%p = %d\n", &i, i);
	printf("子函数 栈中数据地址: 0x%p = %d\n", &j, j);
	printf("子函数 静态数据地址(有初值): 0x%p = %d\n", &s_i, s_i);
	printf("子函数 静态数据地址(无初值): 0x%p = %d\n", &s_j, s_j);
}
int main()
{
	int i = 5;
	static int s_i = 100;
	static int s_j;

	printf("主函数 栈中数据地址: 0x%p = %d\n", &i, i);
	printf("主函数 静态数据地址(有初值): 0x%p = %d\n", &s_i, s_i);
	printf("子函数 静态数据地址(无初值): 0x%p = %d\n", &s_j, s_j);
	putchar('\n');

	fun(i);
	return 0;
}
```
运行结果：

`
主函数 栈中数据地址: 0x0xbfef518c = 5
主函数 静态数据地址(有初值): 0x0x8049890 = 100
子函数 静态数据地址(无初值): 0x0x80498a0 = 0

子函数的参数:        0x0xbfef5170 = 5
子函数 栈中数据地址: 0x0xbfef515c = 5
子函数 静态数据地址(有初值): 0x0x8049894 = 100
子函数 静态数据地址(无初值): 0x0x80498a4 = 0

`

可以看出，主函数中栈的地址都要高于子函数中参数及栈地址，证明了栈的伸展方向是由高地址向低地址扩展的。
主函数和子函数中静态数据的地址也是相邻的，说明程序会将已初始化的全局变量和表态变量分配在一起，
未初始化的全局变量和表态变量分配在另一起。
