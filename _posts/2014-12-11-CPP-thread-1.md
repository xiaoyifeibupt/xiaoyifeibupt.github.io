---
layout: post
title:  使用 C++11 编写 Linux 多线程程序（一）
categories: [c++]
---

-   进程中的某个线程执行了一个阻塞操作时，其它线程可以依然运行，比如，等待用户输入或者等待网络数据包的时候处理启动后台线程处理业务，或者在一个游戏引擎中，一个线程等待用户的交互动作输入，另外一个线程在后台合成下一帧要画的图像或者播放背景音乐等。
-   将某个任务分解为小的可以并行进行的子任务，让这些子任务在不同的 CPU 或者内核上同时进行计算，然后汇总结果，比如归并排序，或者分段查找，这样子来提高任务的执行速度。

需要注意一点，因为单个 CPU 内核下多个线程并不是真正的并行，有些问题，比如 CPU 缓存不一致问题，不一定能表现出来，一旦这些代码被放到了多核或者多 CPU 的环境运行，就很可能会出现“在开发测试环境一切没有问题，到了实施现场就莫名其妙”的情况，所以，在进行多线程开发时，开发与测试环境应该是多核或者多 CPU 的，以避免出现这类情况。

###C++11 的线程类 `std::thread`

C++11 的标准类 `std::thread` 对线程进行了封装，它的声明放在头文件 `thread` 中，其中声明了线程类 `thread`, 线程标识符 `id`，以及名字空间 `this_thread`，按照 C++11 规范，这个头文件至少应该兼容如下内容：

 thread 头文件主要内容
 
 ```cpp
 
namespace std {
    struct thread {
        // native_handle_type 是连接 thread 类和操作系统 SDK API 之间的桥梁。
        typedef implementation-dependent native_handle_type;
        native_handle_type native_handle();
        //
        struct id{
            id() noexcept;
             // 可以由==, < 两个运算衍生出其它大小关系运算。
            bool operator==(thread::id x, thread::id y) noexcept;
            bool operator<(thread::id x, thread::id y) noexcept;
            template<class charT, class traits>
            basic_ostream<charT, traits>&
            operator<<(basic_ostream<charT, traits>&out, thread::id id);
            // 哈希函数
            template <class T> struct hash;
            template <> struct hash<thread::id>;
         };
        id get_id() const noexcept;
        // 构造与析构
        thread() noexcept;
        template<class F, class… Args> explicit thread(F&f, Args&&… args);
        ~thread();
        thread(const thread&) = delete;
        thread(thread&&) noexcept;
        thread& operator=( const thread&) = delete;
        thread& operator=(thread&&) noexcept;
        //
        void swap(thread&) noexcept;
        bool joinable() const noexcept;
        void join();
        void detach();
        // 获取物理线程数目
        static unsigned hardware_concurrency() noexcept;
        }
        
    namespace this_thead {
        thread::id get_id();
        void yield();
        template<class Clock, class Duration>
        void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);
        template<class Rep, class Period>
        void sleep_for(const chromo::duration<Rep, Period>& rel_time);
    }
}
```

C++11 所定义的线程是和操作系的线程是一一对应的，也就是说我们生成的线程都是直接接受操作系统的调度的，通过操作系统的相关命令（比如 `ps -M` 命令）是可以看到的，一个进程所能创建的线程数目以及一个操作系统所能创建的总的线程数目等都由运行时操作系统限定。

`native_handle_type` 是连接 `thread` 类和操作系统 `SDK API` 之间的桥梁，在 g++(libstdc++) for Linux 里面，`native_handle_type` 其实就是 `pthread` 里面的 `pthread_t` 类型，当 `thread` 类的功能不能满足我们的要求的时候（比如改变某个线程的优先级），可以通过 `thread` 类实例的 `native_handle()` 返回值作为参数来调用相关的 `pthread` 函数达到目的。`thread::id` 定义了在运行时操作系统内唯一能够标识该线程的标识符，同时其值还能指示所标识的线程的状态，其默认值 `(thread::id())` 表示不存在可控的正在执行的线程（即空线程，比如，调用 `thead()` 生成的没有指定入口函数的线程类实例），当一个线程类实例的 `get_id()` 等于默认值的时候，即 `get_id() == thread::id()`，表示这个线程类实例处于下述状态之一：

-   尚未指定运行的任务
-   线程运行完毕
-   线程已经被转移 (`move`) 到另外一个线程类实例
-   线程已经被分离 (`detached`)

空线程 id 字符串表示形式依具体实现而定，有些编译器为 0×0，有些为一句语义解释。

有时候我们需要在线程执行代码里面对当前调用者线程进行操作，针对这种情况，C++11 里面专门定义了一个名字空间 `this_thread`，其中包括 `get_id()` 函数可用来获取当前调用者线程的 `id` ，`yield()` 函数可以用来将调用者线程跳出运行状态，重新交给操作系统进行调度，`sleep_until` 和 `sleep_for` 函数则可以让调用者线程休眠若干时间。`get_id()` 函数实际上是通过调用 `pthread_self()` 函数获得调用者线程的标识符，而 `yield()` 函数则是通过调用操作系统 `API sched_yield()` 进行调度切换。

###如何创建和结束一个线程

和 `pthread_create` 不同，使用 `thread` 类创建线程可以使用一个函数作为入口，也可以是其它的 `Callable` 对象，而且，可以给入口传入任意个数任意类型的参数：

例子 thread_run_func_var_args.cc

```cpp
nt funcReturnInt(const char* fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vprintf( fmt, ap );
    va_end(ap);
    return 0xabcd;
}
void threadRunFunction(void) {
    thread* t = new thread(funcReturnInt, "%d%s\n", 100, "\%");
    t->join();
    delete t;
}
```
我们也可以传入一个 Lambda 表达式作为入口，比如：

例子 thread_run_lambda.cc

```cpp
void threadRunLambda(void){
    int a = 100,
    b = 200;
    thread* t = new thread( [](int ia, int ib) {
        cout << (ia + ib) << endl;
        },
        a,
        b);
    t->join();
    delete t;
}
```
一个类的成员函数也可以作为线程入口：

例子 thread_run_member_func.cc

```cpp
struct God{
    void create(const char* anything) {
        cout << "create " << anything << endl;
    }
};
void threadRunMemberFunction(void) {
    God god;
    thread* t = new thread( &God::create, god, "the world" );
    t->join();
    delete t;
}
```
虽然 `thread` 类的初始化可以提供这么丰富和方便的形式，其实现的底层依然是创建一个 `pthread` 线程并运行之，有些实现甚至是直接调用 `pthread_create` 来创建。

创建一个线程之后，我们还需要考虑一个问题：该如何处理这个线程的结束？一种方式是等待这个线程结束，在一个合适的地方调用 `thread` 实例的 `join()` 方法，调用者线程将会一直等待着目标线程的结束，当目标线程结束之后调用者线程继续运行；另一个方式是将这个线程分离，由其自己结束，通过调用 `thread` 实例的 `detach()` 方法将目标线程置于分离模式。一个线程的 `join()` 方法与 `detach()` 方法只能调用一次，不能在调用了 `join()` 之后又调用 `detach()`，也不能在调用 `detach()` 之后又调用 `join()`，在调用了 `join()` 或者 `detach()` 之后，该线程的 `id` 即被置为默认值（空线程），表示不能继续再对该线程作修改变化。如果没有调用 `join()` 或者 `detach()`，那么，在析构的时候，该线程实例将会调用 `std::terminate()`，这会导致整个进程退出，所以，如果没有特别需要，一般都建议在生成子线程后调用其 `join()` 方法等待其退出，这样子最起码知道这些子线程在什么时候已经确保结束。

在 C++11 里面没有提供 `kill` 掉某个线程的能力，只能被动地等待某个线程的自然结束，如果我们要主动停止某个线程的话，可以通过调用 Linux 操作系统提供的 `pthread_kill` 函数给目标线程发送信号来实现，示例如下：

例子 thread_kill.cc

```cpp
static void on_signal_term(int sig){
    cout << "on SIGTERM:" << this_thread::get_id() << endl;
    pthread_exit(NULL); 
}
void threadPosixKill(void){
    signal(SIGTERM, on_signal_term);
    thread* t = new thread( [](){
        while(true){
            ++counter;
        }
    });
    pthread_t tid = t->native_handle();
    cout << "tid=" << tid << endl;
    // 确保子线程已经在运行。
    this_thread::sleep_for( chrono::seconds(1) );
    pthread_kill(tid, SIGTERM);
    t->join();
    delete t;
    cout << "thread destroyed." << endl;
}
```

上述例子还可以用来给某个线程发送其它信号，具体的 `pthread_exit` 函数调用的约定依赖于具体的操作系统的实现，所以，这个方法是依赖于具体的操作系统的，而且，因为在 C++11 里面没有这方面的具体约定，用这种方式也是依赖于 C++编译器的具体实现的。

###线程类 std::thread 的其它方法和特点

`thread` 类是一个特殊的类，它不能被拷贝，只能被转移或者互换，这是符合线程的语义的，不要忘记这里所说的线程是直接被操作系统调度的。线程的转移使用 `move` 函数，示例如下：

例子 thread_move.cc

```cpp
void threadMove(void){
    int a = 1;
    thread t( [](int* pa) {
        for(;;) {
            *pa = (*pa * 33) % 0x7fffffff;
            if ( ( (*pa) >> 30) & 1) break;
        }
    }, &a);
    thread t2 = move(t);   // 改为 t2 = t 将不能编译。
    t2.join();
    cout << "a=" << a << endl;
}
```

在这个例子中，如果将 `t2.join()` 改为 `t.join()` 将会导致整个进程被结束，因为忘记了调用 t2 也就是被转移的线程的 `join()` 方法，从而导致整个进程被结束，而 t 则因为已经被转移，其 id 已被置空。

线程实例互换使用 swap 函数，示例如下：

例子 thread_swap.cc

```cpp
void threadSwap(void) {
    int a = 1;
    thread t( [](int* pa) {
        for(;;){
            *pa = (*pa * 33) % 0x7fffffff;
            if ( ( (*pa) >> 30) & 1) break;
        }
    }, &a);
    thread t2;
    cout << "before swap: t=" << t.get_id() 
        << ", t2=" << t2.get_id() << endl;
    swap(t, t2);
    cout << "after swap : t=" << t.get_id() 
        << ", t2=" << t2.get_id() << endl;
    t2.join();
    cout << "a=" << a << endl;
}
```

互换和转移很类似，但是互换仅仅进行实例（以 id 作标识）的互换，而转移则在进行实例标识的互换之前，还进行了转移目的实例（如下例的t2）的清理，如果 t2 是可聚合的（`joinable()` 方法返回 true），则调用 `std::terminate()`，这会导致整个进程退出，比如下面这个例子：

例子 thread_move_term.cc

```cpp
void threadMoveTerm(void) {
    int a = 1;
    thread t( [](int* pa){
        for(;;){
            *pa = (*pa * 33) % 0x7fffffff;
            if ( ( (*pa) >> 30) & 1) break;
        }
    }, &a);
thread t2( [](){
    int i = 0;
    for(;;)i++;
    } );
    t2 = move(t);  // 将会导致 std::terminate()
    cout << "should not reach here" << endl;
    t2.join();
}
```

所以，在进行线程实例转移的时候，要注意判断目的实例的 id 是否为空值（即 id()）。

如果我们继承了 thread 类，则还需要禁止拷贝构造函数、拷贝赋值函数以及赋值操作符重载函数等，另外，thread 类的析构函数并不是虚析构函数。示例如下：

例子 thread_inherit.cc

```cpp
class MyThread : public thread{
public:
    MyThread() noexcept : thread(){};
    template<typename Callable, typename... Args>
    explicit
    MyThread(Callable&& func, Args&&... args) : 
    thread( std::forward<Callable>(func), 
    std::forward<Args>(args)...){
    }
    ~MyThread() { thread::~thread(); }
    // disable copy constructors
    MyThread( MyThread& ) = delete;
    MyThread( const MyThread& ) = delete;
    MyThread& operator=(const MyThread&) = delete;
};
```

因为 thread 类的析构函数不是虚析构函数，在上例中，需要避免出现下面这种情况：

    MyThread* tc = new MyThread(…);
    
    …
    
    thread* tp = tc;
    
    …
    
    delete tp;

这种情况会导致 MyThread 的析构函数没有被调用。

