---
layout: post
title:  使用 C++11 编写 Linux 多线程程序（三）
categories: [c++]
---

###注意

线程不是静态的，它是不断变化的，使用多线程技术的首要准则是我们自己要十分清楚我们的线程在哪里？线头（线程入口和出口）在哪里？先安排好线程的运行，注意不同线程的交叉点（访问或者修改同一个资源，包括内存、I/O 设备等），尽量减少线程的交叉点。

当我们的确需要不同线程访问一个共同的资源时，一般都需要进行加锁保护，否则很可能会出现数据不一致的情况，从而出现各种时现时不现的莫名其妙的问题，加锁保护时有几个问题需要特别注意：一是**一个线程内连续多次调用非递归锁 (non-recursive lock) 的加锁动作**，这很可能会导致异常；二是**加锁的粒度**；三是出现**死锁 (deadlock)**，多个线程互相等待对方释放锁导致这些线程全部处于罢工状态。

第一个问题只要根据场景调用合适的锁即可，当我们可能会在某个线程内重复调用某个锁的加锁动作时，我们应该使用递归锁 (recursive lock)，在 C++11 中，可以根据需要来使用 recursive_mutex，或者 recursive_timed_mutex。

第二个问题，即锁的粒度，原则上应该是粒度越小越好，那意味着阻塞的时间越少，效率更高，比如一个数据库，给一个数据行 (data row) 加锁当然比给一个表 (table) 加锁要高效，但是同时复杂度也会越大，越容易出错，比如死锁等。

对于第三个问题我们需要先看下出现死锁的条件：

资源互斥，某个资源在某一时刻只能被一个线程持有 (hold)；
吃着碗里的还看着锅里的，持有一个以上的互斥资源的线程在等待被其它进程持有的互斥资源；
不可抢占，只有在某互斥资源的持有线程释放了该资源之后，其它线程才能去持有该资源；
环形等待，有两个或者两个以上的线程各自持有某些互斥资源，并且各自在等待其它线程所持有的互斥资源。
我们只要不让上述四个条件中的任意一个不成立即可。在设计的时候，非常有必要先分析一下会否出现满足四个条件的情况，特别是检查有无试图去同时保持两个或者两个以上的锁，当我们发现试图去同时保持两个或者两个以上的锁的时候，就需要特别警惕了。下面我们来看一个简化了的死锁的例子：

例子 thread_deadlock.cc

```cpp
static mutex g_mutex1, g_mutex2;
static void inc1(int *p ) {
    for(int i = 0; i < COUNT; i++){
        g_mutex1.lock();
        (*p)++;
        g_mutex2.lock();
        // do something.
        g_mutex2.unlock();
        g_mutex1.unlock();
    }
}
static void inc2(int *p ) {
    for(int i = 0; i < COUNT; i++) {
        g_mutex2.lock();
        g_mutex1.lock();
        (*p)++;
        g_mutex1.unlock();
        // do other thing.
        g_mutex2.unlock();
    }
}
void threadMutex(void) {
    int a = 0;
    thread ta( inc1, &a);
    thread tb( inc2, &a);
    ta.join();
    tb.join();
    cout << "a=" << a << endl;
}
```

在这个例子中，`g_mutex1` 和 `g_mutex2` 都是互斥的资源，任意时刻都只有一个线程可以持有（加锁成功），而且只有持有线程调用 `unlock` 释放锁资源的时候其它线程才能去持有，满足条件 1 和 3，线程 `ta` 持有了 `g_mutex1` 之后，在释放 `g_mutex1` 之前试图去持有 `g_mutex2`，而线程 `tb` 持有了 `g_mutex2` 之后，在释放 `g_mutex2` 之前试图去持有 `g_mutex1`，满足条件 2 和 4，这种情况之下，当线程 `ta` 试图去持有 `g_mutex2` 的时候，如果 `tb` 正持有 `g_mutex2` 而试图去持有 `g_mutex1` 时就发生了死锁。在有些环境下，可能要多次运行这个例子才出现死锁，实际工作中这种偶现特性让查找问题变难。要破除这个死锁，我们只要按如下代码所示破除条件 3 和 4 即可：

清单 20.例子 thread_break_deadlock.cc

```cpp
static mutex g_mutex1, g_mutex2;
static void inc1(int *p ) {
    for(int i = 0; i < COUNT; i++) {
        g_mutex1.lock();
        (*p)++;
        g_mutex1.unlock();
        g_mutex2.lock();
        // do something.
        g_mutex2.unlock();
    }
}
static void inc2(int *p ) {
    for(int i = 0; i < COUNT; i++) {
        g_mutex2.lock();
        // do other thing.
        g_mutex2.unlock();
        g_mutex1.lock();
        (*p)++;
        g_mutex1.unlock();
    }
}
void threadMutex(void) {
    int a = 0;
    thread ta( inc1, &a);
    thread tb( inc2, &a);
    ta.join();
    tb.join();
    cout << "a=" << a << endl;
}
```

在一些复杂的并行编程场景，如何避免死锁是一个很重要的话题，在实践中，当我们看到有两个锁嵌套加锁的时候就要特别提高警惕，它极有可能满足了条件 2 或者 4。

###结束语

上述例子在 CentOS 6.5，g++ 4.8.1/g++4.9 以及 clang 3.5 下面编译通过，在编译的时候，请注意下述几点：

设置 `-std=c++11`；
链接的时候设置 `-pthread`；
使用 g++编译链接时设置 `-Wl,–no-as-needed` 传给链接器，有些版本的 g++需要这个设置；
设置宏定义 `-D_REENTRANT`，有些库函数是依赖于这个宏定义来确定是否使用多线程版本的。
具体可以参考本文所附的代码中的 Makefile 文件。

在用 gdb 调试多线程程序的时候，可以输入命令 `info threads` 查看当前的线程列表，通过命令 `thread n` 切换到第 `n` 个线程的上下文，这里的 `n` 是 `info threads` 命令输出的线程索引数字，例如，如果要切换到第 2 个线程的上下文，则输入命令 `thread 2`。
