---
layout: post
title: 动态规划-Dynamic-Programming
categories: [Algorithms]
---

贪心和动态规划是有联系的，贪心是“最优子结构+局部最优”，动态规划是“最优独立重叠子结构+全局最优”。一句话理解动态规划，则是枚举所有状态，然后剪枝，寻找最优状态，同时将每一次求解子问题的结果保存在一张“表格”中，以后再遇到重叠的子问题，从表格中保存的状态中查找（俗称记忆化搜索）。

##1. 最大连续乘积子串

###1.1. 题目描述

给一个浮点数序列，取最大乘积连续子串的值，例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。也就是说，上述数组中，3 0.5 8这3个数的乘积30.58=12是最大的，而且是连续的。

###1.2. 分析与解法

此最大乘积连续子串与最大乘积子序列不同，请勿混淆，前者子串要求连续，后者子序列不要求连续。也就是说，最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence，LCS）是：

子串（Substring）是串的一个连续的部分，
子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；
更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串“ acdfg ”同“ akdfc ”的最长公共子串为“ df ”，而它们的最长公共子序列LCS是“ adf ”，LCS可以使用动态规划法解决。


考虑到乘积子序列中有正有负也还可能有0，我们可以把问题简化成这样：数组中找一个子序列，使得它的乘积最大；同时找一个子序列，使得它的乘积最小（负数的情况）。因为虽然我们只要一个最大积，但由于负数的存在，我们同时找这两个乘积做起来反而方便。也就是说，不但记录最大乘积，也要记录最小乘积。

假设数组为a[]，直接利用动态规划来求解，考虑到可能存在负数的情况，我们用maxend来表示以a[i]结尾的最大连续子串的乘积值，用minend表示以a[i]结尾的最小的子串的乘积值，那么状态转移方程为：

    maxend = max(max(maxend * a[i], minend * a[i]), a[i]);
    minend = min(min(maxend * a[i], minend * a[i]), a[i]);  
    初始状态为maxend = minend = a[0]。

参考代码如下：

    double MaxProductSubstring(double *a, int length){
        double maxEnd = a[0];
        double minEnd = a[0];
        double maxResult = a[0];
        for (int i = 1; i < length; ++i)
        {
            double end1 = maxEnd * a[i], end2 = minEnd * a[i];
            maxEnd = max(max(end1, end2), a[i]);
            minEnd = min(min(end1, end2), a[i]);
            maxResult = max(maxResult, maxEnd);
        }
        return maxResult;
    }
    
动态规划求解的方法一个for循环搞定，所以时间复杂度为O(n)。

###举一反三

1、给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N-1）个数的组合中乘积最大的一组，并写出算法的时间复杂度。
分析：我们可以把所有可能的（N-1）个数的组合找出来，分别计算它们的乘积，并比较大小。由于总共有N个（N-1）个数的组合，总的时间复杂度为O（N2），显然这不是最好的解法。

##2. 字符串编辑距离

###2.1 题目描述

给定一个源串和目标串，能够对源串进行如下操作：
1. 在给定位置上插入一个字符
2. 替换任意字符
3. 删除任意字符

写一个程序，返回最小操作数，使得对源串进行这些操作后等于目标串，源串和目标串的长度都小于2000。

###2.2 分析与解法

此题常见的思路是动态规划，假如令dp[i][j] 表示源串S[0…i] 和目标串T[0…j] 的最短编辑距离，其边界：dp[0][j] = j，dp[i][0] = i，那么我们可以得出状态转移方程：

    dp[i][j] =min{
    dp[i-1][j] + 1 , S[i]不在T[0…j]中
    dp[i-1][j-1] + 1/0 , S[i]在T[j]
    dp[i][j-1] + 1 , S[i]在T[0…j-1]中
    }

接下来，咱们重点解释下上述3个式子的含义

关于dp[i-1][j] + 1, s.t. s[i]不在T[0…j]中的说明

s[i]没有落在T[0…j]中，即s[i]在中间的某一次编辑操作被删除了。因为删除操作没有前后相关性，不妨将其在第1次操作中删除。除首次操作时删除外，后续编辑操作是将长度为i-1的字符串，编辑成长度为j的字符串：即dp[i-1][j]。

因此：dp[i][j] = dp[i-1][j] + 1。

关于dp[i-1][j-1] + 0/1, s.t. s[i] 在T[j]的说明

若s[i]经过编辑，最终落在T[j]的位置。

则要么s[i] == t[j]，s[i]直接落在T[j]。这种情况，编辑操作实际上是将长度为i-1的S’串，编辑成长度为j-1的T’串：即dp[i-1][j-1]；

要么s[i] ≠ t[j]，s[i] 落在T[j]后，要将s[i]修改成T[j]，即在上一种情况的基础上，增加一次修改操作：即dp[i-1][j-1] + 1。
关于dp[i][j-1] + 1, s.t. s[i]在T[0…j-1]中的说明

若s[i]落在了T[1…j-1]的某个位置，不妨认为是k，因为最小编辑步数的定义，那么，在k+1到j-1的字符，必然是通过插入新字符完成的。因为共插入了(j-k)个字符，故编辑次数为(j-k)次。而字符串S[1…i]经过编辑，得到了T[1…k]，编辑次数为dp[i][k]。故： dp[i][j] = dp[i][k] + (j-k)。

由于最后的(j-k)次是插入操作，可以讲(j-k)逐次规约到dp[i][k]中。即：dp[i][k]+(j-k)=dp[i][k+1] + (j-k-1) 规约到插入操作为1次，得到 dp[i][k]+(j-k) =dp[i][k+1] + (j-k-1) =dp[i][k+2] + (j-k-2)=… =dp[i][k+(j-k-1)] + (j-k)-(j-k-1) =dp[i][j-1] + 1。
上述的解释清晰规范，但为啥这样做呢？

换一个角度，其实就是字符串对齐的思路。例如把字符串“ALGORITHM”，变成“ALTRUISTIC”，那么把相关字符各自对齐后，如下图所示：

                   A  L  G  O  R     I     T  H  M
                   A  L     T  R  U  I  S  T  R  C


把图中上面的源串S[0…i] = “ALGORITHM”编辑成下面的目标串T[0…j] = “ALTRUISTIC”，我们枚举字符串S和T最后一个字符s[i]、t[j]对应四种情况：（字符-空白）（空白-字符）(字符-字符)（空白-空白）。

由于其中的（空白-空白）是多余的编辑操作。所以，事实上只存在以下3种情况：

下面的目标串空白，即S + 字符X，T + 空白，S变成T，意味着源串要删字符
dp[i - 1, j] + 1
上面的源串空白，S + 空白，T + 字符，S变成T，最后，在S的最后插入“字符”，意味着源串要添加字符
dp[i, j - 1] + 1
上面源串中的的字符跟下面目标串中的字符不一样，即S + 字符X，T + 字符Y，S变成T，意味着源串要修改字符
dp[i - 1, j - 1] + (s[i] == t[j] ? 0 : 1)
综上，可以写出简单的DP状态方程：

    //dp[i,j]表示表示源串S[0…i] 和目标串T[0…j] 的最短编辑距离
    dp[i, j] = min { dp[i - 1, j] + 1,  dp[i, j - 1] + 1,  dp[i - 1, j - 1] + (s[i] == t[j] ? 0 : 1) }
    //分别表示：删除1个，添加1个，替换1个（相同就不用替换）。

参考代码如下：

    //dp[i][j]表示源串source[0-i)和目标串target[0-j)的编辑距离
    int EditDistance(char *pSource, char *pTarget)
    {
        int srcLength = strlen(pSource);
        int targetLength = strlen(pTarget);
        int i, j;
        //边界dp[i][0] = i，dp[0][j] = j  
        for (i = 1; i <= srcLength; ++i)
        {
            dp[i][0] = i;
        }
        for (j = 1; j <= targetLength; ++j)
        {
            dp[0][j] = j;
        }
        for (i = 1; i <= srcLength; ++i)
        {
            for (j = 1; j <= targetLength; ++j)
            {
                if (pSource[i - 1] == pTarget[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[srcLength][targetLength];
    }

###2.3 举一反三

1、传统的编辑距离里面有三种操作，即增、删、改，我们现在要讨论的编辑距离只允许两种操作，即增加一个字符、删除一个字符。我们求两个字符串的这种编辑距离，即把一个字符串变成另外一个字符串的最少操作次数。假定每个字符串长度不超过1000，只有大写英文字母组成。

2、有一亿个数，输入一个数，找出与它编辑距离在3以内的数，比如输入6（0110），找出0010等数，数是32位的。


##3. 交替字符串

###3.1. 题目描述

输入三个字符串s1、s2和s3，判断第三个字符串s3是否由前两个字符串s1和s2交错而成，即不改变s1和s2中各个字符原有的相对顺序，例如当s1 = “aabcc”，s2 = “dbbca”，s3 = “aadbbcbcac”时，则输出true，但如果s3=“accabdbbca”，则输出false。

###3.2. 分析与解法

此题不能简单的排序，因为一旦排序，便改变了s1或s2中各个字符原始的相对顺序，既然不能排序，咱们可以考虑下用动态规划的方法，令dp[i][j]代表s3[0...i+j-1]是否由s1[0...i-1]和s2[0...j-1]的字符组成

如果s1当前字符（即s1[i-1]）等于s3当前字符（即s3[i+j-1]），而且dp[i-1][j]为真，那么可以取s1当前字符而忽略s2的情况，dp[i][j]返回真；
如果s2当前字符等于s3当前字符，并且dp[i][j-1]为真，那么可以取s2而忽略s1的情况，dp[i][j]返回真，其它情况，dp[i][j]返回假
参考代码如下：

    public boolean IsInterleave(String s1, String 2, String 3){
    int n = s1.length(), m = s2.length(), s = s3.length();
    
    //如果长度不一致，则s3不可能由s1和s2交错组成
    if (n + m != s)
        return false;
    
    boolean[][]dp = new boolean[n + 1][m + 1];
    
    //在初始化边界时，我们认为空串可以由空串组成，因此dp[0][0]赋值为true。
    dp[0][0] = true;
    
    for (int i = 0; i < n + 1; i++){
        for (int j = 0; j < m + 1; j++){
            if ( dp[i][j] || (i - 1 >= 0 && dp[i - 1][j] == true &&
                //取s1字符
                s1.charAT(i - 1) == s3.charAT(i + j - 1)) ||
    
                (j - 1 >= 0 && dp[i][j - 1] == true &&
                //取s2字符
                s2.charAT(j - 1) == s3.charAT(i + j - 1)) )
    
                dp[i][j] = true;
            else
                dp[i][j] = false;
        }
    }
    return dp[n][m]
    }

理解本题及上段代码，对真正理解动态规划有一定帮助。

##4. 最大子数组和

###4.1. 题目描述

一个整数数组，一个非空的子数组（连续一段数），使得它的和最大 (Leetcode 53)

###4.2. 分析和解法

####4.2.1. 解法一——DP

    dp[i]表示以a[i]结尾的最大子数组的和
    dp[i] = max(dp[i – 1] + a[i], a[i])
    包含a[i – 1]：dp[i – 1] + a[i]
    不包含a[i – 1]: a[i]
    初值 dp[0] = a[0]
    答案？最大的dp[0..n – 1]
    时间复杂度 O(n), 空间复杂度O(n)
    空间优化: dp[i]要存么？
    endHere = max(endHere + a[i], a[i])
    结果answer = max(endHere, answer)

####4.2.2. 解法二——线性枚举


定义

    sum[i] = a[0] + a[1] + a[2] +…+ a[i]   i>=0
    sum[-1] = 0

则 对 0 <= i <= j

    a[i] + a[i + 1] + … + a[j] = sum[j] – sum[i – 1]
  
我们就是要求这样一个最大值
对j我们可以求得当前的sum[j]，取的i – 1一定是之前最小的sum值，用一个变量记录sum的最小值
时间O(n),空间O(1)




##5. 二维数组路径最小和

###5.1. 题目描述

一个m行n列的二维数组，每个元素是一个非负数，从左上角走到右下角，每次只能朝右或者下走，不能走出矩阵，使得总和最小。

###5.2. 分析和解法

dp[i][j]表示从左上到达(i,j)的最小值
dp[i][j] = min(dp[i – 1][j], dp[i][j – 1]) + a[i][j]
从上边过来dp[i – 1][j] + a[i][j]
从左边过来dp[i][j – 1] + a[i][j]
初值  (下标从0开始）
dp[0][0] = a[0][0] 
dp[0][j > 0] = dp[0][j – 1] + a[0][j]
dp[i > 0][0] = dp[i – 1][0] + a[i][0]
复杂度: 时间O(m * n), 空间O(m * n)

空间优化——省掉一维

dp[i][j]只与dp[i – 1][j] , dp[i][j – 1]有关
对每个i,正向循环j
之前的dp[j – 1]是“新的”，dp[j]还是旧的
dp[j] = min(dp[j – 1], dp[j]) + a[i][j] 更新
