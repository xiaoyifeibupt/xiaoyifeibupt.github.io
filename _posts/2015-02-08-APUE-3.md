---
layout: post
title: 文件IO
categories: [APUE]
---


文件IO通常来说只需要用到下面5个函数：open，read，write，lseek，close

这里read/write就是不带缓冲的IO,因为它们直接进行系统调用而不再用户态进行缓冲。相对应的 是标准IO,

标准IO在用户态进行了数据缓冲。不带缓冲IO不是ISO C的组成部分，但是却是POSIX和 SUS的组成部分。

###文件描述符
对于文件IO来说，操作的对象就是文件描述符。这是一个非负整数。通常来说系统会使用0,1,2来作为 进程的标准输入，输出和错误。但是最好不要依赖这个行为，而使用

	#include <unistd.h>
	#define STDIN_FILENO 0
	#define STDOUT_FILENO 1
	#define STDERR_FILENO 2

同时需要注意的是，对于进程打开的文件描述符是存在上限的，可以通过sysconf得到。

###open/create

`open`打开文件返回文件描述符。允许指定读写方式，是否创建(`OCREAT`)，如果文件存在并且创建是否会出错(`OEXCL`)， 是否追加，是否`truncate`,是否阻塞，权限等标记，同时还允许指定是否每次`write`需要等待物理IO操作完成。 对于open每次一定都是返回最小的未使用的文件描述符。而create可以理解为`open`的包装.注意这里`OCREAT`也非常关键，语义是入如果不存在就创建，这样使得这个操作成为一个原子操作。

	#include<fcnt1.h>	
	int open(const char *pathname, int oflag, ... /* mode_t mode */ )

	#include<fcnt1.h>
	int creat(const char * pathname, mode_t mode);
	相当于
	open(const char * pathname ,(O_CREAT|O_WRONLY|O_TRUNC));
	
由于creat函数创建文件后是以只写的方式打开，因此局限性比较大，所以一般都用open函数来代替creat函数创建一个文件，这样创建后就能同时以读写的方式打开文件了。


###close

close允许关闭文件描述符。关闭一个文件会释放该进程在文件上所有记录锁。程序退出的时候 自动关闭所有打开的文件描述符，利用这点很多程序在退出时候并不显示关闭文件描述符。

	#include <unistd.h>
	int close(int fd);

需要说明的是，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件。

###lseek

lseek允许显示设置文件当前偏移量。如果文件描述符是一个管道，FIFO或者是网络套接字的话，那么 会返回ESPIPE的错误。需要注意的是lseek仅仅是修改进程对于这个文件访问逻辑偏移，实际上不进行任何 物理IO操作。使用lseek允许造成文件空洞(通常见于core文件),空洞部分并不要求占用磁盘存储空间。

	#include<unistd.h>
	off_t lseek(int fildes,off_t offset ,int whence);

参数 fildes 为已打开的文件描述符，参数 offset 为根据参数 whence 来移动读写位置的位移数。

offset：偏移量，每一读写操作所需要移动的距离，单位是字节的数量，可正可负（向前移，向后移）。

whence为下列其中一种:（SEEK_SET,SEEK_CUR和SEEK_END和依次为0，1和2）

-	SEEK_SET 将读写位置指向文件头后再增加offset个位移量。
-	SEEK_CUR 以目前的读写位置往后增加offset个位移量。
-	SEEK_END 将读写位置指向文件尾后再增加offset个位移量。

当whence 值为SEEK_CUR 或SEEK_END时，参数offet允许负值的出现。

下列是较特别的使用方式:
-	欲将读写位置移到文件开头时:
		lseek（int fildes,0,SEEK_SET）；

-	 欲将读写位置移到文件尾时:
		lseek（int fildes,0,SEEK_END）；

-	想要取得目前文件位置时:
		lseek（int fildes,0,SEEK_CUR）；

**特殊用法**

	off_t currpos;
	currpos = lseek(fd, 0, SEEK_CUR);
	
这个技巧也可用于判断我们是否可以改变某个文件的偏移量。如果参数 fd（文件描述符）指定的是 pipe（管道）、FIFO 或者 socket，lseek 返回 -1 并且置 errno 为 ESPIPE。

对于普通文件（regular file），cfo 是一个非负整数。但对于特殊设备，cfo 有可能是负数。因此，我们不能简单地测试 lseek 的返回值是否小于 0 来判断 lseek 成功与否，而应该测试 lseek 的返回值是否等于 -1 来判断 lseek 成功与否。


**例子**

	#include <fcntl.h>
	#include <unistd.h>
	#include <cstring>
	int main(){
	    int fd=open("hole",O_WRONLY | O_CREAT,0666);
	    write(fd,"1G hole are coming",strlen("1G hole are coming"));
	    lseek(fd,1024*1024*1024,SEEK_CUR);
	    write(fd,"1G hole are ending",strlen("1G hole are ending"));
	    close(fd);
	    return 0;
	}

创建1G的空洞，可以查看

	$ ll hole
	-rw-r--r-- 1 dirlt dirlt 1073741860 05-17 08:11 hole
	
	$ du -h hole
	20K     hole

关于占用多少真实磁盘大小是文件系统所关心的，Linux下面使用20K来保存空洞文件。 另外需要关心`lseek`问题就是文件大小的情况，我们可以使用`FILEOFFSETBITS`来控制偏移量的范围， 这样就允许操作更大的文件了。如果`-D_FILE_OFFSET_BITS=64`
的话，那么偏移量就允许在264.这种规模的文件是相当大的了。尽管可以支持64位文件偏移，但是是否 允许创建这么大的文件，还是最终取决于文件系统的能力。

###read

read从文件当前偏移开始读出数据，并且修改当前文件偏移。read允许指定需要读取数据多少，但是并不一定 会返回这么多的数据回来，那么这个时候read返回值就是已经读取的字节数。基本上对于终端，网络， 管道，FIFO等文件，都需要多次读取才能够完成，比较例外的就是磁盘了。同时我们必须注意信号 终端情况，这个时候read会返回EINTR的错误，通常来说我们还需要继续读。

	#include<unistd.h>
	ssize_t read(int fildes,void *buf ,size_t nbytes);


###write

write也是从当前偏移开始写数据的，然后修改当前文件偏移。如果设置了OAPPEND选项打开文件的话， 那么write每次写操作，都会首先移动到文件最末尾然后写数据。这个选项非常重要，可以让文件 追加写成为原子操作。

	#include<unistd.h>
	ssize_t write(int fildes,const void *buf ,size_t nbytes);


###pread/pwrite

pread/pwrite相当于一个方便的lseek+read/write操作，并且有一个特点就是不修改当前文件偏移。

	#include <fcntl.h>
	#include <unistd.h>
	#include <cstring>
	#include <cstdio>
	int main(){
	    int fd=open("main.cc",O_RDONLY);
	    char buf[128];
	    memset(buf,0,sizeof(buf));
	    for(int i=0;i<10;i++){
	        //每次读取到的都是相同的内容
	        pread(fd,buf,sizeof(buf)-1,128);
	        printf("%s\n",buf);
	    }
	    close(fd);
	    return 0;
	}

###dup/dup2

	int dup(int fd);
	int dup2(int src_fd,int dst_fd);

dup2允许指定将srcfd复制给某个dstfd,而dup是将fd复制给最小未使用的fd. dup2相当于一个原子操作，首先关闭dstfd然后再复制到dstfd上面。

###sync/fsync/fdatasync

操作系统为了提高文件读写效率，在内核层提供了读写缓冲区。对于磁盘的写并不是立刻写入磁盘， 而是首先写入页面缓冲区然后定时刷到硬盘上。但是这种机制降低了文件更新速度，并且如果系统发生故障 的话，那么会造成部分数据丢失。这里的3个sync函数就是为了这个问题的。

-	sync.是强制将所有页面缓冲区都更新到磁盘上。
-	fsync.是强制将某个fd涉及到的页面缓存更新到磁盘上(包括文件属性等信息).
-	fdatasync.是强制将某个fd涉及到的数据页面缓存更新到磁盘上。

###fcntl

全称是file control,可以改变已经打开文件的性质，共有下面5种功能：

-	FDUPFD.复制现有描述符。
-	FGETFD/FSETFD.获得/设置现有文件描述符标记(现只有FDCLOEXEC).
-	FSETFL/FGETFL.获得/设置现有文件状态标记。
-	FGETOWN/FSETOWN.获得/设置当前接受SIGIO和SIGURG信号的进程ID和进程组ID(设置异步IO所有权).
-	FGETLK/FSETLK/FSETLKW.获得/设置记录锁。

###ioctl

全称是io control.ioctl是IO操作杂物箱，终端IO是ioctl的最大使用方面。ioctl包含的头文件是

	#include <unistd.h>
	#include <sys/ioctl.h>
	#include <stropts.h>

但是这仅仅是ioctl所需要包含的文件，不同设备还有专有的头文件：


类别	常量	头文件

-	盘标号	DIOxxx	<sys/disklabel.h>
-	文件IO	FIOxxx	<sys/filio.h>
-	磁带IO	MTIOxxx	<sys/mtio.h>
-	套接字IO	SIOxxx	<sys/sockio.h>
-	终端IO	TIO	<sys/ttycom.h>

###/dev/fd/n

文件	对象

-	/dev/fd/0	标准输入
-	/dev/stdin	
-	/dev/fd/1	标准输出
-	/dev/stdout	
-	/dev/fd/2	标准错误
-	/dev/stderr	

使用open打开任何一个文件，相当于进行了dup操作一样进行了文件描述符复制。并且需要注意的是，比如 对于标准输入只允许读的话，那么如果open使用RDWR打开的话那么写依然是没有作用的。在shell下面如果 程序需要传入一个文件名从文件里面读入内容的话，我们提供/dev/fd/0的话，那么程序就可以从标准输入 中读取内容，这点非常方便。

###底层实现

这节主要说文件描述符是如何管理的，假设在一个系统中存在很多进程(process),每个进程里面有一个文件 描述符表，大致结构如下：

	struct Process{
	    //这是一个数组，文件描述符就是下标。
	    vector<FileDescriptorEntry> entries;
	};
	struct FileDescriptorEntry{
	    bool close_on_exec; //调用exec是否关闭
	    bool other_flags; //其他标记
	    OpenedFileTable* ft_ptr; //指向全局的打开文件表表项
	};

然后系统维护一个打开表文件表表项，在每个进程的文件描述符里面有对应的表项指针。大致结构如下：

	struct OpenedFileTable{
	    int status; //状态标志，比如O_RDWR,O_APPEND,OSYNC等。
	    off_t offset; //当前偏移
	    vnode_t* vnode; //所指向的vnode
	};

在进程复制一个文件描述符并没有增加一个新的表项，而是指向相同的表项。然后vnodet就是 文件系统对应的内容了，包括位置大小属性等等信息。
