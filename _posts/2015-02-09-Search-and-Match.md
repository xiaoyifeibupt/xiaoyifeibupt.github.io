---
layout: post
title: 查找匹配
categories: [Algorithms]
---
【整理自July】
##1. 有序数组的查找

###1.1. 题目描述

给定一个有序的数组，查找某个数是否在数组中，请编程实现。

###1.2. 分析与解法

一看到数组本身已经有序，我想你可能反应出了要用二分查找，毕竟二分查找的适用条件就是有序的。那什么是二分查找呢？

二分查找可以解决（预排序数组的查找）问题：只要数组中包含T（即要查找的值），那么通过不断缩小包含T的范围，最终就可以找到它。其算法流程如下：

一开始，范围覆盖整个数组。
将数组的中间项与T进行比较，如果T比数组的中间项要小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。
如此，每次查找可以排除一半元素，范围缩小一半。就这样反复比较，反复缩小范围，最终就会在数组中找到T，或者确定原以为T所在的范围实际为空。
对于包含N个元素的表，整个查找过程大约要经过log(2)N次比较。

此时，可能有不少读者心里嘀咕，不就二分查找么，太简单了。

然《编程珠玑》的作者Jon Bentley曾在贝尔实验室做过一个实验，即给一些专业的程序员几个小时的时间，用任何一种语言编写二分查找程序（写出高级伪代码也可以），结果参与编写的一百多人中：90%的程序员写的程序中有bug（我并不认为没有bug的代码就正确）。

也就是说：在足够的时间内，只有大约10%的专业程序员可以把这个小程序写对。但写不对这个小程序的还不止这些人：而且高德纳在《计算机程序设计的艺术 第3卷 排序和查找》第6.2.1节的“历史与参考文献”部分指出，虽然早在1946年就有人将二分查找的方法公诸于世，但直到1962年才有人写出没有bug的二分查找程序。

你能正确无误的写出二分查找代码么？不妨一试，关闭所有网页，窗口，打开记事本，或者编辑器，或者直接在本文评论下，不参考上面我写的或其他任何人的程序，给自己十分钟到N个小时不等的时间，立即编写一个二分查找程序。

要准确实现二分查找，首先要把握下面几个要点：

关于right的赋值

	right = n-1 => while(left <= right) => right = middle-1;
	right = n => while(left < right) => right = middle;

`middle`的计算不能写在`while`循环外，否则无法得到更新。

以下是一份参考实现：

	int BinarySearch(int array[], int n, int value)
	{
	    int left = 0;
	    int right = n - 1;
	    //如果这里是int right = n 的话，那么下面有两处地方需要修改，以保证一一对应：
	    //1、下面循环的条件则是while(left < right)
	    //2、循环内当 array[middle] > value 的时候，right = mid
	
	    while (left <= right)  //循环条件，适时而变
	    {
			//防止溢出，移位也更高效。同时，每次循环都需要更新。
	        int middle = left + ((right - left) >> 1);  
	
	        if (array[middle] > value)
	        {
	            right = middle - 1;  //right赋值，适时而变
	        }
	        else if(array[middle] < value)
	        {
	            left = middle + 1;
	        }
	        else
	            return middle;
	        //可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多
	        //如果每次循环都判断一下是否相等，将耗费时间
	    }
	    return -1;
	}

###1.3. 总结

编写二分查找的程序时

如果令 `left <= right`，则`right = middle - 1`;

如果令`left < right`，则 `right = middle`;

换言之，算法所操作的区间,是左闭右开区间,还是左闭右闭区间,这个区间,需要在循环初始化。且在循环体是否终止的判断中,以及每次修改`left`, `right`区间值这三个地方保持一致,否则就可能出错。


##2. 行列递增矩阵的查找

###2.1. 题目描述

在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

例如下面的二维数组就是每行、每列都递增排序。如果在这个数组中查找数字6，则返回true；如果查找数字5，由于数组不含有该数字，则返回false。

			1	2	8	9
			2	4	9	12
			4	7	10	13
			6	8	11	15

###2.2. 分析与解法

####2.2.1. 解法一、分治法

这种行和列分别递增的矩阵，有一个专有名词叫做杨氏矩阵，由剑桥大学数学家杨表在1900年推提出，在这个矩阵中的查找，俗称杨氏矩阵查找。

以查找数字6为例，因为矩阵的行和列都是递增的，所以整个矩阵的对角线上的数字也是递增的，故我们可以在对角线上进行二分查找，如果要找的数是6介于对角线上相邻的两个数4、10，可以排除掉左上和右下的两个矩形，而在左下和右上的两个矩形继续递归查找



####2.2.2. 解法二、定位法

首先直接定位到最右上角的元素，再配以二分查找，比要找的数（6）大就往左走，比要找数（6）的小就往下走，直到找到要找的数字（6）为止，这个方法的时间复杂度O（m+n）。如下图所示：
img

关键代码如下所示：

	#define ROW 4
	#define COL 4
	
	bool YoungMatrix(int array[][COL], int searchKey){
	    int i = 0, j = COL - 1;
	    int var = array[i][j];
	    while (true){
	        if (var == searchKey)
	            return true;
	        else if (var < searchKey && i < ROW - 1)
	            var = array[++i][j];
	        else if (var > searchKey && j > 0)
	            var = array[i][--j];
	        else
	            return false;
	    }
	}

###2.3. 举一反三

1、给定 n×n 的实数矩阵，每行和每列都是递增的，求这 n^2 个数的中位数。

2、我们已经知道杨氏矩阵的每行的元素从左到右单调递增，每列的元素从上到下也单调递增的矩阵。那么，如果给定从1-n这n个数，我们可以构成多少个杨氏矩阵呢？

例如n = 4的时候，我们可以构成1行4列的矩阵：

1 2 3 4

2个2行2列的矩阵:

1 2

3 4

和

1 3

2 4

还有一个4行1列的矩阵

1

2

3

4

因此输出4。


##3. 出现次数超过一半的数字
###3.1. 题目描述

题目：数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。

###3.2. 分析与解法

一个数组中有很多数，现在我们要找出其中那个出现次数超过总数一半的数字，怎么找呢？大凡当我们碰到某一个杂乱无序的东西时，我们人的内心本质期望是希望把它梳理成有序的。所以，我们得分两种情况来讨论，无序和有序。

####3.2.2. 解法一

如果无序，那么我们是不是可以先把数组中所有这些数字先进行排序（至于排序方法可选取最常用的快速排序）。排完序后，直接遍历，在遍历整个数组的同时统计每个数字的出现次数，然后把那个出现次数超过一半的数字直接输出，题目便解答完成了。总的时间复杂度为O(nlogn + n)。

但如果是有序的数组呢，或者经过排序把无序的数组变成有序后的数组呢？是否在排完序O(nlogn)后，还需要再遍历一次整个数组？

我们知道，既然是数组的话，那么我们可以根据数组索引支持直接定向到某一个数。我们发现，一个数字在数组中的出现次数超过了一半，那么在已排好序的数组索引的N/2处（从零开始编号），就一定是这个数字。自此，我们只需要对整个数组排完序之后，然后直接输出数组中的第N/2处的数字即可，这个数字即是整个数组中出现次数超过一半的数字，总的时间复杂度由于少了最后一次整个数组的遍历，缩小到O(n*logn)。

然时间复杂度并无本质性的改变，我们需要找到一种更为有效的思路或方法。

####3.2.2. 解法二

既要缩小总的时间复杂度，那么可以用查找时间复杂度为O(1)的hash表，即以空间换时间。哈希表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。然后直接遍历整个hash表，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可。

####3.2.3. 解法三

Hash表需要O(n)的空间开销，且要设计hash函数，还有没有更好的办法呢？我们可以试着这么考虑，如果每次删除两个不同的数（不管是不是我们要查找的那个出现次数超过一半的数字），那么，在剩下的数中，我们要查找的数（出现次数超过一半）出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除掉其它的数，最终找到那个出现次数超过一半的数字。这个方法，免去了排序，也避免了空间O(n)的开销，总得说来，时间复杂度只有O(n)，空间复杂度为O(1)，貌似不失为最佳方法。

举个简单的例子，如数组a[5] = {0, 1, 2, 1, 1};

很显然，若我们要找出数组a中出现次数超过一半的数字，这个数字便是1，若根据上述思路4所述的方法来查找，我们应该怎么做呢？通过一次性遍历整个数组，然后每次删除不相同的两个数字，过程如下简单表示：

0 1 2 1 1 =>2 1 1=>1
最终1即为所找。

但是数组如果是{5, 5, 5, 5, 1}，还能运用上述思路么？很明显不能，咱们得另寻良策。

####3.2.4. 解法四

更进一步，考虑到这个问题本身的特殊性，我们可以在遍历数组的时候保存两个值：一个candidate，用来保存数组中遍历到的某个数字；一个nTimes，表示当前数字的出现次数，其中，nTimes初始化为1。当我们遍历到数组中下一个数字的时候：

如果下一个数字与之前candidate保存的数字相同，则nTimes加1；

如果下一个数字与之前candidate保存的数字不同，则nTimes减1；

每当出现次数nTimes变为0后，用candidate保存下一个数字，并把nTimes重新设为1。 直到遍历完数组中的所有数字为止。

举个例子，假定数组为{0, 1, 2, 1, 1}，按照上述思路执行的步骤如下：

1.开始时，candidate保存数字0，nTimes初始化为1；

2.然后遍历到数字1，与数字0不同，则nTimes减1变为0；

3.因为nTimes变为了0，故candidate保存下一个遍历到的数字2，且nTimes被重新设为1；

4.继续遍历到第4个数字1，与之前candidate保存的数字2不同，故nTimes减1变为0；

5.因nTimes再次被变为了0，故我们让candidate保存下一个遍历到的数字1，且nTimes被重新设为1。最后返回的就是最后一次把nTimes设为1的数字1。

思路清楚了，完整的代码如下：

	//a代表数组，length代表数组长度
	int FindOneNumber(int* a, int length)
	{
	    int candidate = a[0];
	    int nTimes = 1;
	    for (int i = 1; i < length; i++)
	    {
	        if (nTimes == 0)
	        {
	            candidate = a[i];
	            nTimes = 1;
	        }
	        else
	        {
	            if (candidate == a[i])
	                nTimes++;
	            else
	                nTimes--;
	        }
	    }
	    return candidate;
	}
	
即针对数组{0, 1, 2, 1, 1}，套用上述程序可得：

	i=0，candidate=0，nTimes=1；
	i=1，a[1] != candidate，nTimes--，=0；
	i=2，candidate=2，nTimes=1；
	i=3，a[3] != candidate，nTimes--，=0；
	i=4，candidate=1，nTimes=1；
	如果是0，1，2，1，1，1的话，那么i=5，a[5] == candidate，nTimes++，=2；......


###3.3. 举一反三

加强版水王：找出出现次数刚好是一半的数字

分析：我们知道，水王问题：有N个数，其中有一个数出现超过一半，要求在线性时间求出这个数。那么，我的问题是，加强版水王：有N个数，其中有一个数刚好出现一半次数，要求在线性时间内求出这个数。

因为，很明显，如果是刚好出现一半的话，如此例： 0，1，2，1 ：

	遍历到0时，candidate为0，times为1
	遍历到1时，与candidate不同，times减为0
	遍历到2时，times为0，则candidate更新为2，times加1
	遍历到1时，与candidate不同，则times减为0；我们需要返回所保存candidate（数字2）的下一个数字，即数字1。



