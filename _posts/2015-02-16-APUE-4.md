---
layout: post
title:  APUE——文件和目录
categories: [APUE]
---

获取一个文件属性可以使用下面这几个函数来获得：

	stat(const char* restrict pathname,struct stat* restrict buf);
	fstat(int fd,struct stat* restrict buf);
	lstat(const char* restrict pathname,struct stat* restrict buf);

其中lstat和stat区别就是lstat是获取软链接文件属性的。

	struct stat{
	    mode_t st_mode; //文件类型和访问权限
	    ino_t st_ino; //inode编号
	    dev_t st_dev; //设备号(对于文件系统来说)
	    dev_t st_rdev; //设备号(对于特殊文件来说)
	    nlink_t st_nlink; //链接数目
	    uid_t st_uid; //文件所有者uid
	    gid_t st_gid; //文件所有者gid
	    off_t st_size; //文件大小
	    time_t st_atime; //access time
	    time_t st_mtime; //modification time
	    time_t st_ctime; //属性最近一次change time
	    blksize_t st_blksize; //block size
	    blkcnt_t st_blocks; //blocks
	};

###文件系统


首先我们可以将一块磁盘进行分区，这样每个区就可以在上面建立一个文件系统。 一个文件系统可以表示为下面这样的数据结构：

	//Physical File System
	strcut PFS{
	    //这个部分内容可以直接载入内存来进行管理
	    Block boot; //自举块
	    Block super; //超级块
	    Configuration config; //配置信息
	    Bitmap inode_bitmap; //inode节点的bitmap
	    Bitmap dblock_bitmap; //数据块的bitmap
	    //下面这些内容不能够载入内存
	    Inode inodes[]; //inode节点数组
	    DataBlock dblocks[]; //数据块数组
	};

可以看到为了管理一个文件系统，在内存中主要存放inode和数据块的bitmap,表示哪些inode和 数据块是空闲的。

然后对于Inode节点来说，里面存放的就是数据块的索引。这里为了概念上表示方便而使用数组 表示的，实际上Inode可能有简介索引，指向的并不一定就是直接可以的读取数据块，可能数据块 上面存放的是更多数据块的指针。

	struct Inode{
	    FileAttribute attr; //文件属性
	    index_t datablock[]; //数据块的索引
	};

但是可以确信一点的就是，一个文件在同一个文件系统中对应一个inode.文件属性对应的就是 struct stat这个结构。可以看到文件属性是存放在inode节点上而不是数据块上的。

对于一个目录项来说，结构大致如下：

	//目录项
	struct DirectoryEntry{ 
	    char filename[]; //文件名
	    index_t inode; //对应的inode索引
	};
	
	struct Directory{
	    DirectoryEntry entries[]; //目录项数组
	};

目录里面存放的就是文件名和对应的inode索引。

对于符号链接来说，在文件属性标记是否为符号链接，然后磁盘内容就是目的地文件系统路径。

	$ touch a
	$ ln -s ./a b
	$ ln -s /home/dirlt/cvs/opencode/zyspace/doc/a b2
	$ ll b b2
	lrwxrwxrwx 1 dirlt dirlt  3 05-19 08:14 b -> ./a
	lrwxrwxrwx 1 dirlt dirlt 38 05-19 08:15 b2 -> /home/dirlt/cvs/opencode/zyspace/doc/a


可以看到b长度为3,正好等于"./a"长度，而b2长度为38也等于"/home/dirlt/cvs/opencode/zyspace/doc/a"长度。

###文件类型

对应的是stmode这个字段。文件类型有下面这几类，系统也提供了特殊的宏来判断到底是 什么样的文件类型：

-	普通文件(SISREG)
-	目录文件(SISDIR)
-	字符特殊文件(SISCHR)
-	块特殊文件(SISBLK)
-	FIFO文件(SISFIFO)
-	符号链接文件(SISLNK)
-	套接字文件(SISSOCK)

在Linux上面为了使用SISSOCK需要使用GNUSOURCE这个选项。然后需要注意的是，系统中 所有的设备要么是字符特殊文件，要么是块特殊文件。字符特殊文件针对设备是不带缓冲的 访问，每次访问长度可变，而块特殊设备对于访问提供缓冲并且以固定长度为单位进行。


###设置用户ID和设置组ID

对于一个进程来说，相关联的ID有下面几个：

ID	作用

-	实际用户ID	实际上我们是谁
-	实际组ID	
-	有效用户ID	以什么权限运行
-	有效组ID	
-	保存的设置用户ID	由exec函数保存
-	保存的设置组ID	关于保存的设置ID判断条件是POSIXSAVEDIDS/SCSAVEDIDS.

通常来说有效uid和gid等同于实际uid和gid.但是对于一些特殊程序比如需要修改passwd,那么 程序执行时必须以另外一种用户启动，所以区分了这两个概念。

	$ ll /usr/bin/passwd 
	-rwsr-xr-x 1 root root 25708 2007-09-26 /usr/bin/passwd

我们调用passwd修改密码，实际uid和gid是我们自己，而运行uid和gid则是root.为了查看文件 是否设置了这个功能，我们可以使用SISUID和SISGID查看stmode相应位。

	#include <sys/stat.h>
	#include <cstdio>
	int main(){
	    struct stat buf;
	    stat("/usr/bin/passwd",&buf);
	    printf("is_uid:%d\n",(buf.st_mode && S_ISUID)!=0);
	    printf("is_gid:%d\n",(buf.st_mode && S_ISGID)!=0);
	    printf("owner uid:%d\n",buf.st_uid);
	    printf("owner gid:%d\n",buf.st_gid);
	    return 0;
	}
	is_uid:1
	is_gid:1
	owner uid:0
	owner gid:0

###文件访问权限

文件访问权限也可以通过访问stmode来获得，有下面9个权限位：

权限	意义
-	SIRUSR	user read
-	SIWUSR	user write
-	SIXUSR	user exec
-	SIRGRP	group read
-	SIWGRP	group write
-	SIXGRP	group exec
-	SIROTH	other read
-	SIWOTH	other write
-	SIXOTH	other exec

在谈论规则之前，有必要解释一下目录的执行权限。目录是一个特殊文件，可以将目录想象 成为里面都是文件的名称然后配上必要的索引信息。对于一个目录的读权限，就是可以获得 里面所有的文件名内容，而对于执行权限就是可以搜索其中特定的文件名。

文件访问权限有下面这些规则：

-	读写权限控制了我们是否可以读写文件。
-	打开任意类型文件，必须有效uid和文件owner uid匹配或者是gid匹配，或者是超级权限。
-	打开任意类型文件，必须有所有目录的执行权限。
-	在目录下面创建文件需要对这个目录有写和执行权限。
-	创建的文件的uid和gid分别是有效的uid和有效的gid.
-	删除文件必须有效uid和文件owner uid匹配，或者是gid匹配，或者是超级权限。
-	删除文件必须对目录有写和执行权限，但是不需要对文件有读写权限。
-	执行文件必须对文件有执行权限，并且文件还是一个普通文件。

其实对于创建文件来说，新文件的gid owner还可能是另外一种情况，那就是继承上级目录的gid owner. 对于Linux系统方式是这样的：如果上级目录设置了设置gid位的话，那么就继承上级的gid owner, 否则就使用创建者的有效gid.(个人觉得按照创建者的有效uid和gid比较好理解问题):).

###access函数

检测访问权限。但是需要注意的是，access函数是按照实际uid和gid来检测的，而不是按照进程的 有效uid和gid来检测的。

####umask

传入参数mask是权限位的组合，对于open和mkdir创建文件和目录权限的话，会除去mask中的标记。比如 mask为SIRUSR | SIWUSR的话，那么在创建文件和目录时，那么用户读写权限位就会被屏蔽。需要注意的是mask是进程的属性。

####chmod/fchmod

修改现有文件的访问权限。出了上面列列举权限位可以使用之外，还有下面这些：

权限位	说明
-	SISUID	开启设置uid
-	SISGID	开启设置gid
-	SISVTX	保存正文(粘住位)
-	SIRWXU	user rwx
-	SIRWXG	group rwx
-	SIRWXO	other rwx

如果非超级用户并且试图设置粘住位，那么粘住位会被清除。

如果新文件gid不等于进程有效gid,并且非超级用户，那么设置gid位会被清除。

对于在分页机制出来之前的Unix操作系统，设置粘住位可以使得程序的正文段始终驻留在内存中来加快程序运行速度， 很明显结果就是粘住位文件数量有一定限制，但是采用分页机制之后这个不需要了。而现在粘住位主要 是针对目录来设置的。对于目录设置了粘住位之后，那么具有下面权限之一才允许删除或者是更名目录下面的文件：

-	拥有此文件
-	拥有此目录
-	超级用户

对于/tmp目录非常适合。每个用户都可以写入文件，虽然用户对目录有执行和写权限，但是却不允许 删除或者是更名/tmp目录下面的文件。

####chown/fchown/lchown

修改文件的uid和gid.如果值为-1的话表明对应id不变。如果开启了POSIXCHOWNRESTRICTED的话，那么

超级用户才允许更改uid.

有效uid==文件uid,或者是文件uid不变有效gid==文件gid,那么允许更改gid.

同时需要注意的是，如果函数由非超级用户调用，设置uid和gid为都会被清除。

###文件长度

文件长度对应stsize字段，而文件使用的块大小对应stblksize字段，占用块数对应stblocks字段。 大部分情况下面，stsize和stblksize*stblocks应该是很接近的，除非一种情况就是文件空洞。 一般对应于空洞文件来说，stsize可能很大，而实际占用磁盘空间却很少。

	#include <sys/types.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <cstring>
	#include <cstdio>
	int main(){
	    //产生一个空洞文件
	    int fd=open("hole",O_WRONLY | O_CREAT,0666);
	    write(fd,"1G hole are coming",strlen("1G hole are coming"));
	    lseek(fd,1024*1024*1024,SEEK_CUR);
	    write(fd,"1G hole are ending",strlen("1G hole are ending"));
	    close(fd);
	    struct stat buf;
	    stat("hole",&buf);
	    printf("size:%lu,st_blksize:%lu,st_blocks:%lu\n",
	           buf.st_size,buf.st_blksize,buf.st_blocks);
	    return 0;
	}

	$ ./main 
	size:1073741860,st_blksize:4096,st_blocks:40

###文件截断

	int truncate(const char* filename,off_t length);
	int ftruncate(int fd,off_t length);

如果length比原来文件短的话，那么文件在length偏移之后数据就不可以访问了。如果length比 原来文件长的话，那么会创造一个空洞出来

	#include <sys/types.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <cstring>
	#include <cstdio>
	int main(){
	    int fd=open("hole",O_WRONLY | O_CREAT,0666);
	    close(fd);
	    truncate("hole",1024*1024*1024);
	    struct stat buf;
	    stat("hole",&buf);
	    printf("size:%lu,st_blksize:%lu,st_blocks:%lu\n",
	           buf.st_size,buf.st_blksize,buf.st_blocks);
	    return 0;
	}

	$ ./main 
	size:1073741824,st_blksize:4096,st_blocks:8

###文件链接

关于文件链接分为硬链接和软链接，软链接也称为符号链接在之前提到过。

创建一个硬链接效果就是，选择一个文件名然后选择一个已经使用的inode编号存放在目录下面。 一旦创建硬链接之后，那么被链接的文件的属性里面就会将链接数目+1.链接数目对应于struct stat 结构里面的stnlink字段。

	int link(const char* existingpath,const char* newpath);

可以看到硬链接是使用inode节点来操作的，所以硬链接是不可以跨越文件系统的。另外需要注意的是， 大多数操作系统仅限于超级用户进行目录的硬链接，因为这样做可能会造成文件系统中形成循环，而 大多数程序无法处理这种情况而且很容易搞乱文件系统。

符号链接也对应是一个文件，指向另外一个文件。所以在这里我们必须弄清楚，如果操作 符号链接的话，哪些是操作链接文件，哪些是操作真实文件：

函数	不跟随链接	跟随链接
access			Y
chdir		Y
chmod		Y
chown		Y
creat		Y
exec		Y
lchown	Y	
link		Y
lstat	Y	
open		Y
opendir		Y
pathconf		Y
readlink	Y	
remove	Y	
rename	Y	
stat		Y
truncate		Y
unlink	Y	

创建符号链接和读取符号链接函数为symlink和readlink.

###文件删除和重命名

为了解除硬链接可以使用下面这个函数：

	int unlink(const char* pathname);

因为文件链接数目如果为0的话，那么文件就会被删除，所以这个函数也可以用来删除文件。 解除硬链接必须包含对于目录的写和执行权限。如果文件设置了粘住位的话，除了具有写权限之外， 还必须有下面其中一个条件：

-	拥有该文件
-	拥有该目录
-	超级用户

关于文件删除也可以使用remove函数，效果和unlink一样。不过对于目录来说内部调用rmdir.

在删除文件是后需要注意的一个问题是这样的，就是即使stnlink==0的话，如果系统中 还有进程在访问这个文件的话，那么磁盘空间仍然不会释放，知道进程关闭这个文件之后 才会释放磁盘空间。甚至来说，如果进程持有这个fd的话，这个文件依然是可写的。

	#include <cstdio>
	#include <fcntl.h>
	#include <unistd.h>
	int main(){
	    int fd=open("hello",O_RDWR | O_TRUNC | O_CREAT,0666);
	    unlink("hello");
	    write(fd,"hello",6);
	    lseek(fd,0,SEEK_SET);
	    char buf[12];
	    buf[0]=0;
	    read(fd,buf,sizeof(buf));
	    //尽管之前unlink了
	    //依然可以读取到hello
	    printf("%s\n",buf);
	    close(fd);
	}

重命名使用函数rename.关于重命名会涉及目录，所以这里看看行为：

-	oldname是文件：newname不能够是目录，newname如果存在首先删除，然后创建newname
-	oldname是目录：newname不能够是文件，newname如果存在必须是空目录然后删除，然后创建newname

###文件时间

文件时间分为：

-	最后访问时间(read)
-	最后修改时间(write)
-	最后更改时间(chmod,chown)

修改时间和更改时间差别是，修改时间是修改数据块内容时间，而更改时间是更改inode节点的时间， 差别就好比操作文件实际内容和文件属性。不同操作影响时间不同，而且还会影响所在父目录的时间。

函数	文件access	文件modify	文件change	父access	父modify	父change
chmod/fchmod			Y			
chown/fchown			Y			
creat(OCREAT)	Y	Y	Y		Y	Y
creat(OTRUNC)		Y	Y			
exec	Y					
lchown			Y			
link			Y		Y(2nd param)	Y(2nd param)
mkdir	Y	Y	Y		Y	Y
mkfifo	Y	Y	Y		Y	Y
open(OCREAT)	Y	Y	Y		Y	Y
open(OTRUNC)		Y	Y			
read	Y					
remove(unlink)			Y		Y	Y
remove(rmdir)					Y	Y
rename			Y		Y	Y
rmdir					Y	Y
truncate/ftruncate		Y	Y			
unlink			Y		Y	Y
utime	Y	Y	Y			
write		Y	Y			

###目录操作

创建目录函数是mkdir和rmdir.mkdir常犯错误是权限为0666和文件相同，通常来说目录是 需要可执行权限，不然我们不能够在下面创建目录。rmdir要求目录必须是空目录。 和删除文件一样，如果链接数为0并且没有进程打开之后才会释放空间。如果链接数==0时候， 有其他进程打开目录的话，那么会删除.和..,然后也不允许添加新的目录项，等到打开目录 进程退出之后，才会释放磁盘空间。

读取目录函数是：

-	opendir
-	readdir
-	rewinddir
-	closedir
-	telldir
-	seekdir

readdir访问到的文件顺序和目录实现相关

chdir,fchdir可以帮助切换当前工作目录，而getcwd可以获得当前工作目录是什么。 当前工作目录是一个进程的概念，所以如果A调用B的话，即使B调用chdir切换工作目录， B执行完成之后，A的工作目录不会发生变化。

###特殊设备文件

stdev是设备号，分为主次设备号：

	major(buf.st_dev) //主设备号
	minor(buf.st_dev) //次设备号

主设备号表示设备驱动程序，而次设备号表示特定的子设备。比如在同一个磁盘上面 不同的文件系统，设备驱动程序相当，但是次设备号不同。

strdev只有字符特殊文件和块特殊文件才有这个值，表示实际设备的设备编号。

	#include <sys/types.h>
	#include <sys/stat.h>
	#include <cstdio>
	int main(int argc,char * const* argv){
	    for(int i=1;i<argc;i++){
	        struct stat buf;
	        stat(argv[i],&buf);
	        printf("%s dev=%d/%d",argv[i],
	               major(buf.st_dev),minor(buf.st_dev));
	        if(S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)){
	            if(S_ISCHR(buf.st_mode)){
	                printf(" (character)");
	            }else if(S_ISBLK(buf.st_mode)){
	                printf(" (block)");
	            }
	            printf(" rdev=%d/%d",
	                   major(buf.st_rdev),minor(buf.st_rdev));
	        }
	        printf("\n");
	    }
	    return 0;
	}

	[]$ mount
	/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
	proc on /proc type proc (rw)
	sysfs on /sys type sysfs (rw)
	devpts on /dev/pts type devpts (rw,gid=5,mode=620)
	/dev/sda1 on /boot type ext3 (rw)
	tmpfs on /dev/shm type tmpfs (rw)
	none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
	sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)

	[]$ df
	Filesystem           1K-blocks      Used Available Use% Mounted on
	/dev/mapper/VolGroup00-LogVol00
	                      19552940   2649028  15894660  15% /
	/dev/sda1               194442     12450    171953   7% /boot
	tmpfs                   127628         0    127628   0% /dev/shm

	[]$ ./main /boot/ /dev/shm /tmp /home /dev/cdrom /dev/tty0 
	/boot/ dev=8/1
	/dev/shm dev=0/18
	/tmp dev=253/0
	/home dev=253/0
	/dev/cdrom dev=0/16 (block) rdev=11/0
	/dev/tty0 dev=0/16 (character) rdev=4/0
