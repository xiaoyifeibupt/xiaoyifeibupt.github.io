---
layout: post
title:  APUE——标准I/O库
categories: [APUE]
---

###流和定向

对于文件IO来说，所有IO函数都是针对文件描述符展开的。而对于标准IO而言，所有函数 都只针对流展开的。管理的结构是FILE,通常是一个结构体，通常里面包含了：

-	文件fd
-	缓冲区指针
-	缓冲区长度
-	当前缓冲区读取长度
-	出错标志

然后大部分标准IO使用的都是FILE*结构体指针来操作的。

使用函数fileno可以得到fd.而对于其他字段的话，因为本身就是一个struct结构，只需要 阅读stdio.h里面的FILE结构就可以看到每个字段的意思并且可以得到它们。

流的定向(stream's orientation)决定了所读写的字符是单字节还是多字节的。一个流最初创建 的时候并没有定向，直到第一次使用的时候才被确定。有两个函数可以修改流的定向：

	freopen.这个函数清除了流的定向。
	fwide(FILE* fp,int mode).这个函数修改流的定向。


对于文件IO使用了0,1,2分别表示标准输入，输出和错误，对应的标准IO也提供了预定义的三个 流来，分别是stdin,stdout和stderr.

###缓冲

标准IO相对于文件IO最便利的地方就是提供了缓冲。缓冲的话大部分情况能够改善程序的性能， 虽然大部分使用标准IO需要提供一次额外的copy,但是相对于频繁进行系统调用来说还是值得的。

标准IO提供了下面三种缓冲：

-	全缓冲
-	行缓冲
-	不带缓冲

全缓冲是指填满IO缓冲区之后在进行实际的IO操作，通常来说对于驻留在磁盘上的文件使用 全缓冲。在流上第一次实行IO操作的时候，标准IO就会通过malloc分配一块缓冲区。如果使用 全缓冲需要强制进行实际操作的话，可以调用fflush来冲刷。对于flush有两层意思，对于 标准IO而言，flush是将缓冲区的内容进行实际IO操作，而对于设备驱动程序而言，就是 丢弃缓冲区里面的内容。

	#include <cstdio>
	#include <unistd.h>
	int main(){
	    //退出后输出
	    char buffer[1024];
	    setvbuf(stdout,buffer,_IOFBF,sizeof(buffer));
	    printf("helloworld");
	    sleep(2);
	    return 0;
	}

行缓冲是指输入和输出遇到换行符之后，标准IO库才执行IO操作。当然如果缓冲区已经满了 的话，那么也是会进行的。并且任何时候如果标准IO库从一个不带缓冲的流，或者是从内核 得到数据的带行缓冲流中获得数据的话，会造成冲洗所有行缓冲输出流。(what fucking is that?). 通常来说对于终端设备比如标准输入和输出的时候，使用行缓冲。

	#include <cstdio>
	#include <unistd.h>
	int main(){
	    //退出后输出
	    char buffer[128];    
	    setvbuf(stdout,buffer,_IOLBF,sizeof(buffer));
	    printf("helloworld");
	    sleep(2);
	    return 0;
	}
	#include <cstdio>
	#include <unistd.h>
	int main(){
	    //立刻输出
	    char buffer[128];    
	    setvbuf(stdout,buffer,_IOLBF,sizeof(buffer));
	    printf("helloworld\n");
	    sleep(2);
	    return 0;
	}
	#include <cstdio>
	#include <unistd.h>
	int main(){
	    //立刻输出
	    //可以看到并不是说缓冲区足够的情况下不输出
	    //内置有另外一套算法，对于128那么就并没有输出
	    //而对于64立刻输出，但是其实都没有填满
	    char buffer[64];    
	    setvbuf(stdout,buffer,_IOLBF,sizeof(buffer));
	    printf("helloworld");
	    sleep(2);
	    return 0;
	}

关于行缓冲这个部分确实很迷惑人。

不带缓冲是指不对字符进行任何缓冲。通常对于标准错误来说，希望信息尽可能地快地显示 出来，所以不带缓冲。

对于Linux平台来说：

-	标准错误是不带缓冲的。
-	终端设备是行缓冲的。
-	其他都是全缓冲的。
-	也提供了API来设置缓冲模式：

	//打开和关闭缓冲模式
	//如果buf!=NULL,buf必须是BUFSIZE大小缓冲区，那么选择合适的缓冲模式
	//如果buf==NULL,那么表示不带缓冲
	void setbuf(FILE* restrict fp,char* restrict buf);

	//mode可以执行什么缓冲模式
	//如果不带缓冲，那么忽略buf和isze
	//如果带缓冲，那么使用buf和size.如果buf==NULL,那么size=BUFSIZE
	int setvbuf(FILE* restrict fp,char* restrict buf,int mode,size_t size);

关于fflush也之前也提过了，如果fflush传入参数为NULL的话，那么会刷出所有的输出流。

可以看到，标准IO提供了很多一次刷新所有输出流(fflush)和一次刷新所有行输出流，并且 如果程序退出之前没有关闭流的话，那么标准IO会自动帮助我们关闭。那么基本上可以了解， 在实现层面上，我们打开一个流对象，在标准IO都会进行簿记的。


###打开和关闭流

打开流提供了下面这些函数：

	//打开pathname
	FILE* fopen(const char* restrict pathname,const char* restrict type);
	//关闭fp,然后打开pathname,和fp进行关联
	FILE* freopen(const char* restrict pathname,const char* restrict type,FILE* restrict fp);
	//将打开的fd映射成为流
	FILE* fdopen(int fd,const char* type);

通常来说freopen的用途是，将fp设置成为stdin,stdout或者是stderr,这样原来操作fprintf函数的话， 就可以直接关联到文件上面了，而不需要修改很多代码即可完成。

关于type有下面这几种枚举值

-	type	说明
-	r/rb	读打开
-	w/wb	截断写打开，如果不存在创建
-	a/ab	追加写打开，如果不存在创建
-	r+/r+b/rb+	读写打开
-	w+/w+b/wb+	截断读写打开，如果不存创建
-	a+/a+b/ab+	追加读写打开，如果不存在创建 对于fdopen的type比较特殊，type不能够指定创建还是截断，并且关于读写模式必须和fd的属性相同。

因为标准IO内部只是维护一个缓冲区，如果读写交替的话，那么实际上会打乱内部buffer内容。 所以如果使用+打开的话，在交替输出和输入的时候，需要进行flush操作，可以使用下面这些函数：

-	fseek
-	fseeko
-	fsetpos
-	rewind
-	fflush

关于流使用fclose函数，在文件关闭之前会冲洗缓冲区的输出数据，并且丢弃缓冲区的任何输入数据。 并且如果IO库已经分配一个缓冲区的话，那么需要显示地释放这块缓冲区。

###读写流

####字符IO

包括下面这些：

	int getc(FILE* fp);
	int fgetc(FILE* fp);
	int getchar();
	int ungetc(int c,FILE* fp); //回退到流
	int putc(int c,FILE* fp);
	int fputc(int c,FILE* fp);
	int putchar();

其中getc和fgetc,以及putc和fputc的差别就是,getc/putc可以实现为宏，而fgetc和fputc必须是 函数，我们可以得其地址。

对于get函数来说，我们返回的是int.如果达到末尾或者是出错的话，那么就会返回EOF(-1).为了判断 是因为出错还是因为文件结束的话，我们可以使用函数：

	feof
	ferror

文件FILE里面记录了结束位和出错位，调用clearerr可以清除。

使用ungetc可以回退一个字符到流中。回退的字符不允许是EOF,如果回退成功的话，那么会清除 该流文件的文件结束标志。

####行IO

包括下面这些：

	char* fgets(char* restrict buf,int n,FILE* restrict fp);
	char* gets(char* buf);
	int fputs(const char* restrict str,FILE* restrict fp);
	int puts(const char* str);

我们尽量避免使用gets这样的函数。对于fxxx和xxx之间一个最重要的区别是，fxxx需要我们自己 来处理换行符，而xxx自动帮助我们处理了换行符。

####二进制IO

包括下面这些：

	//其中size表示一个对象的大小，nobj表示需要读取多少个对象
	size_t fread(void* restrict ptr,size_t size,size_t nobj,FILE* restrict fp);
	size_t fwrite(const void* restrict ptr,size_t size,size_t nobj,FILE* restrict fp);

返回值表示读写对象个数，如果==0的话，那么需要判断出错还是文件结束。

####格式化IO

输出包括下面这些函数：

	printf
	fprintf
	sprintf
	snprintf
	vprintf
	vfprintf
	vsprintf
	vsnprintf

输入包括下面这些函数：

	scanf
	fscanf
	sscanf
	vscanf
	vfscanf
	vsscanf

里面最重要的就是format格式，但是了解format格式非常tedious并且获益并不是很大，如果需要 设计某种小型的数据驱动语言的话，可以参考这个东西非常有帮助。

###定位流

包括下面这些：

	long ftell(FILE* fp);
	off_t ftello(FILE* fp); 
	
	//whence包括
	//SEEK_SET 从头
	//SEEK_CUR 当前
	//SEEK_END 末尾
	int fseek(FILE* fp,long offset,int whence);
	int fseeko(FILE* fp,off_t offset,int whence);
	
	//回到头部
	void rewind(FILE* fp);
	
	//如果移植到非UNIX平台建议使用
	int fgetpos(FILE* restrict fp,fpos_t* restrict pos);
	int fsetpos(FILE* fp,const fpos_t* pos);

其中ftello/ftell和fseeko/fseek之间的差别，就是类型不同，分别是offt和long.

###临时文件

创建临时文件的接口有：

	char* tmpnam(char* ptr);
	FILE* tmpfile(void);
	char* tempnam(const char* directory,const char* prefix);
	int mkstemp(char* template);

tmpnam的ptr传入一个Ltmpnam长度的buf,然后会返回一个临时文件的名称，最多调用TMPMAX次。

	#include <cstdio>
	int main(){
	    char name[L_tmpnam];
	    printf("%d\n",TMP_MAX);
	    for(int i=0;i<10;i++){
	        name[0]=0;
	        tmpnam(name);
	        printf("%s\n",name);
	    }
	    return 0;
	}

临时文件目录都是在/tmp目录下面的

	[]$ ./main                  
	238328
	/tmp/fileroni3c
	/tmp/filehspHQc
	/tmp/file5Us9Dc
	/tmp/file4gKJrc
	/tmp/fileKgUsfc
	/tmp/file3wqf3b
	/tmp/fileTDb5Qb
	/tmp/fileGCrXEb
	/tmp/filexBfVsb
	/tmp/filepoJVgb

tmpfile可以返回一个"wb+"打开临时文件流。基本上可以认为tmpfile是这样操作的：

tmpname产生一个文件名
然后fopen(…,"wb+")打开
然后unlink这个文件
但是因为这种间存在一定的时间空隙，tmpfile保证原子操作行。并且注意到最后unlink了， 所以不需要用来自己删除文件:).

tempnam相对于tmpnam来说功能更强大，但是至于是否好用就不好说了。对于tempnam可以在 不同目录下面生成临时文件(顺序比较诡异):

如果有环境变量TMPDIR,那么在directory为TMPDIR.

如果directory不为NULL的话，那么使用directory.

<cstdio>定义的Ptmpdir.

而prefix是最多包含5个字符的字符串。然后内部使用malloc来构造，所以最终需要自己释放。

	#include <cstdio>
	#include <cstdlib>
	#include <unistd.h>
	int main(){
	    printf("%s\n",P_tmpdir);
	    //只取前面5个字符
	    char* p=tempnam("/var/tmp","helloworld");
	    printf("%s\n",p);
	    free(p);
	    p=tempnam(NULL,"helloworld");
	    printf("%s\n",p);
	    free(p);
	    return 0;
	}


	[]$ ./main               
	/tmp
	/var/tmp/hello7wVj3K
	/tmp/helloqNEpql
	[dirlt@localhost.localdomain]$ TMPDIR=/home/ ./main 
	/tmp
	/home/hellopg7ANi
	/home/hello1xmviW

mkstemp要求template是一个路径名称，最后面是6个XXXXXX,然后会修改这6个字符。然后 一旦创建成功之后返回文件描述符就可以使用。但是需要注意的是，mkstemp相对于tmpfile 并不会自动进行unlink,所以需要用户自己进行unlink.