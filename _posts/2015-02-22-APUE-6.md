---
layout: post
title:  APUE——系统数据文件和信息
categories: [APUE]
---



Unix系统正常允许需要使用大量和系统相关的数据文件，有些数据文件是ASCII文件有些 是二进制文件，但是为了方便接口来处理，所以提供一系列访问的接口。

###口令文件

口令文件存储于/ect/passwd下面，每一行是一个记录按照:进行分隔：

root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
news:x:9:13:news:/etc/news:
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
gopher:x:13:30:gopher:/var/gopher:/sbin/nologin
ftp:x:14:50:FTP User:/:/sbin/nologin
nobody:x:99:99:Nobody:/:/sbin/nologin
dbus:x:81:81:System message bus:/:/sbin/nologin

之前提到过每个字段含义。可以看到密码都是使用x表示。如果不希望用户登录的话，那么提供 一个不存在的shell比如/sbin/noshell或者是/sbin/nologin.

所涉及到的结构和接口包括：

	#include <pwd.h>
	struct passwd {
	    char    *pw_name;      /* user name */
	    char    *pw_passwd;    /* user password */
	    uid_t   pw_uid;        /* user id */
	    gid_t   pw_gid;        /* group id */
	    char    *pw_gecos;     /* real name */
	    char    *pw_dir;       /* home directory */
	    char    *pw_shell;     /* shell program */
	};


	//按照uid和name来进行查找
	//内部实现可以理解为使用下面例程来完成的
	struct passwd* getpwuid(uid_t uid);
	struct passwd* getpwnam(const char* name);
	
	//得到下一个entry.如果没有打开文件会自动打开
	//不是线程安全的
	struct passwd* getpwent(void);
	//从头开始entry
	void setpwent(void);
	//关闭entry访问接口
	void endpwent(void);
	#include <pwd.h>
	#include <cstdio>
	int main(){
	    setpwent();
	    struct passwd* pw=getpwent();
	    while(pw){
	        printf("%s:%s:%d:%d:%s:%s:%s\n",
	               pw->pw_name,pw->pw_passwd,pw->pw_uid,pw->pw_gid,
	               pw->pw_gecos,pw->pw_dir,pw->pw_shell);
	        pw=getpwent();
	    }
	    endpwent();
	    return 0;
	}


###阴影口令

虽然密码是进行单向加密算法加密的，但是如果攻击者如果进行密码碰撞检测的话，并且配合 工程学的知识来破解的话，相对来说比较容易破解。所以之后Unix系统将单向加密值放在/etc/shadow 文件下面，这个文件只有root可以阅读。格式和/etc/shadow一样：

	root:$1$s4hs87U1$ti.Gd2Nh/JiQ6L.SuSg7L1:14927:0:99999:7:::
	dirlt:$1$BRt79uEo$PtCKwZNuUB7x5zyOKVRi00:14927:0:99999:7:::

访问结构和接口有下面这些：

	#include <shadow.h>
	struct spwd {
	    char          *sp_namp; /* user login name */
	    char          *sp_pwdp; /* encrypted password */
	    long int      sp_lstchg; /* last password change */
	    long int      sp_min; /* days until change allowed. */
	    long int      sp_max; /* days before change required */
	    long int      sp_warn; /* days warning for expiration */
	    long int      sp_inact; /* days before account inactive */
	    long int      sp_expire; /* date when account expires */
	    unsigned long int  sp_flag; /* reserved for future use */
	};
	//使用name查找，底层还是调用下面拿几个函数
	struct spwd* getspnam(const char* name);
	struct spwd* getspent();
	void setspent();
	vodi endspent();

###组文件

格式和/etc/passwd一样，最后一个字段按照,分开：

	root:x:0:root
	bin:x:1:root,bin,daemon
	daemon:x:2:root,bin,daemon
	sys:x:3:root,bin,adm
	adm:x:4:root,adm,daemon
	tty:x:5:
	dirlt:x:500

结构和接口有下面这些：

	#include <grp.h>
	struct group {
	    char   *gr_name;       /* group name */
	    char   *gr_passwd;     /* group password */
	    gid_t   gr_gid;        /* group ID */
	    char  **gr_mem;        /* group members */
	};
	//按照gid和group name来检索
	struct group* getgrgid(gid_t gid);
	struct group* getgrnam(const char* name);
	//遍历接口
	struct group* getgrent();
	void setgrent();
	void endgrent();
	#include <grp.h>
	#include <cstdio>
	int main(){
	    setgrent();
	    struct group *gp=getgrent();
	    while(gp){
	        printf("%s:%s:%d:",gp->gr_name,gp->gr_passwd,gp->gr_gid);
	        if(*(gp->gr_mem)){
	            while(*(gp->gr_mem+1)){
	                printf("%s,",*(gp->gr_mem));
	                gp->gr_mem++;
	            }
	            printf("%s",*(gp->gr_mem));
	        }
	        printf("\n");
	        gp=getgrent();
	    }
	    endgrent();
	    return 0;
	}

###其他数据文件

其他数据文件所提供的接口和上面很相似，包括遍历接口和查找接口。

说明	数据文件	头文件	结构	查找函数

-	口令	/etc/passwd	<pwd.h>	passwd	getpwnam,getpwuid
-	组	/etc/group	<grp.h>	group	getgrnam,getgrgid
-	阴影文件	/etc/shadow	<shadow.h>	spwd	getspnam
-	主机	/etc/hosts	<netdb.h>	hostent	gethostbyname/addr
-	网络	/etc/networks	<netdb.h>	netent	getnetbyname/addr
-	协议	/etc/protocols	<netdb.h>	protoent	getprotobyname/number
-	服务	/etc/services	<netdb.h>	servent	getservbyname/port

###登录账户记录

Unix提供了下面这两个数据文件utmp和wtmp.其中utmp记录当前登录进入系统的各个用户， 而wtmp是跟踪各个登录和注销事件，内部都是相同的二进制记录。在Linux系统上，两个 文件的存放位置分别是/var/run/utmp和/var/log/wtmp,查看man utmp可以查看二进制的 格式：

	struct exit_status {
	    short int e_termination;    /* process termination status */
	    short int e_exit;           /* process exit status */
	};
	
	struct utmp {
	    short ut_type;              /* type of login */
	    pid_t ut_pid;               /* PID of login process */
	    char ut_line[UT_LINESIZE];  /* device name of tty - "/dev/" */
	    char ut_id[4];              /* init id or abbrev. ttyname */
	    char ut_user[UT_NAMESIZE];  /* user name */
	    char ut_host[UT_HOSTSIZE];  /* hostname for remote login */
	    struct exit_status ut_exit; /* The exit status of a process
	                                   marked as DEAD_PROCESS */
	
	    /* The ut_session and ut_tv fields must be the same size when
	       compiled 32- and 64-bit.  This allows data files and shared
	       memory to be shared between 32- and 64-bit applications */
	#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32
	    int32_t ut_session;         /* Session ID, used for windowing */
	    struct {
	        int32_t tv_sec;         /* Seconds */
	        int32_t tv_usec;        /* Microseconds */
	    } ut_tv;                    /* Time entry was made */
	#else
	    long int ut_session;        /* Session ID, used for windowing */
	    struct timeval ut_tv;       /* Time entry was made */
	#endif
	
	    int32_t ut_addr_v6[4];       /* IP address of remote host */
	    char __unused[20];           /* Reserved for future use */
	};

登录时，login进程填写此结构，写入utmp和wtmp文件中，注销时init进程将utmp 文件中对应记录擦除并且增加一条新记录到wtmp文件中。并且在系统重启，修改系统 时间和日期之后，都会在wtmp文件中追加一条记录。

utmp和wtmp虽然都是二进制文件，但是Linux系统了系统命令可以用来查看这两个 文件，分别是who和last.:).

###系统标识

uname函数可以返回和当前主机和操作系统相关信息：

	#include <sys/utsname.h>
	int uname(struct utsname *buf);
	struct utsname {
	    char sysname[];
	    char nodename[];
	    char release[]; 
	    char version[];
	    char machine[];
	#ifdef _GNU_SOURCE
	    char domainname[];
	#endif
	};

需要注意的是nodename不能够用于引用网络通信主机，仅仅适用于引用UUCP网络上的主机。 如果需要返回TCP网络主机的话，可以使用gethostname这个函数：

	#include <unistd.h>
	int gethostname(char* name,int namelen);
	#include <sys/utsname.h>
	#include <unistd.h>
	#include <cstdio>
	int main(){
	    struct utsname buf;
	    uname(&buf);
	    printf("sysname:%s\n"
	           "nodename:%s\n"
	           "release:%s\n"
	           "version:%s\n"
	           "machine:%s\n"
	           "domainname:%s\n",
	           buf.sysname,buf.nodename,
	           buf.release,buf.version,
	           buf.machine,buf.domainname);
	    char host[128];
	    gethostname(host,sizeof(host));
	    printf("hostname:%s\n",host);
	    return 0;
	}
	[dirlt@localhost.localdomain]$ ./main 
	sysname:Linux
	nodename:localhost.localdomain
	release:2.6.23.1-42.fc8
	version:#1 SMP Tue Oct 30 13:55:12 EDT 2007
	machine:i686
	domainname:(none)
	hostname:localhost.localdomain

###时间和日期例程

Unix所提供的时间和日期是存放在一个量值里面的，就是timet.表示从国际标准时间1970年 1月1日00:00:00至今的秒数，使用调用time可以获得。当然Unix也提供了一系列的函数来进行转换和本地化操作， 包括夏时制转换以及转换成为本地时区的时间。当然Unix也提供了更加精确到微妙的调用gettimeofday。

	struct timeval{
	    time_t tv_sec; //这个分量还是表示秒
	    long tv_usec; //微秒
	};

timet是一个秒的概念，Unix还提供了下面结构可以表达日期时间概念：

	struct tm {
	    int tm_sec;         /* seconds */ //[0,60]60表示闰秒
	    int tm_min;         /* minutes */
	    int tm_hour;        /* hours */
	    int tm_mday;        /* day of the month */
	    int tm_mon;         /* month */
	    int tm_year;        /* year */ //since 1900
	    int tm_wday;        /* day of the week */
	    int tm_yday;        /* day in the year */
	    int tm_isdst;       /* daylight saving time */ //>0夏时制生效
	};

当然得到这个结构用户还必须自己制作字符串，所以还有字符串表达方式(const char*)。

	from	to	function	受TZ影响
	timet	struct tm	gmtime	否
	timet	struct tm	localtime	是
	struct tm	timet	mktime	否
	timet	const char*	ctime	是
	struct tm	const char*	asctime	否
	struct tm	const char*	strftime	是 

受TZ影响的意思是受环境变量TZ的影响，TZ可以用来定义我们系统所处的时区。