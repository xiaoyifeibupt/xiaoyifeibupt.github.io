---
layout: post
title:  APUE——进程环境
categories: [APUE]
---

###进程启动

对于一个C程序来说，在调用main之前首先调用一个特殊例程，链接器在链接成为可执行程序的时候， 就将这个特殊例程设置成为程序起始地址。启动例程从内核中得到命令行参数和环境变量，然后调用main 函数。

###进程终止

有下面8中终止方式，其中5种为正常方式：

-	main返回。好比调用exit(main(argc,argv))
-	exit.
-	exit/Exit
-	最后一个线程从启动例程返回。
-	最后一个线程调用pthreadexit.

异常终止有下面三种：

-	abort.
-	接收到信号并且终止。
-	最后一个线程对取消请求作出响应。

exit和exit/Exit的差别在于，exit首先执行一段程序然后进入内核，而exit/Exit就直接立刻进入内核。 

exit所作的事情包括执行atexit注册函数，冲刷标准IO流，关闭标准IO流等事情(但是文件描述符关闭放在内核完成). 参数是退出状态，然后进入内核之后退出状态结合进程自身结果，组合成为终止状态，返回给外部。

关于 退出状态和终止状态会在下一章说明。exit/Exit之间没有差别，只不过exit是POSIX定义的，而 _Exit是ISO C所定义的。

我们可以使用atexit来注册退出清理函数，个数是有上限的，而且允许重复设置。退出时候执行 顺序和设置时候顺序相反。

###C程序存储空间布局

从历史上讲，C程序一直有下面这几个部分组成：

正文段(text).程序代码

初始化数据段(data).有初始化值的全局和静态变量

非初始化数据段(bss,block started by symbol).没有初始化值的全局和静态变量，初始化值为0。

栈(stack).

堆(heap).

典型的逻辑布局是：

| .text | .data | .bss | .heap(->) | zero block | (<-).stack | argv & environ |
其中.text被安排在低地址，而argv & environ被安排在高地址。堆栈按照不同的方向进行增长， 中间有一个非常大的zero block是没有被使用的虚拟内存，所有的mmap都是在这方面开辟的。

对于一个ELF文件来说，还有若干其他类型的短，比如包含符号表的段，调试信息的段和包含 动态共享库链接表的段，而这些端并不装载到进程执行的程序映像中。反过来说，对于 程序映像中，只有.text和.data段内容是在二进制文件里面保存的，而.bss是不保存的。 也没有必要，因为程序只需要知道这个段大小然后初始化为0即可。

使用size命令可以查看各个段大小：

	[]$ size /usr/bin/gcc /usr/libexec/gcc/i386-redhat-linux/4.1.2/cc1plus /bin/bash
	   text    data     bss     dec     hex filename
	 196215    4124       0  200339   30e93 /usr/bin/gcc
	5893175   16584  544620 6454379  627c6b /usr/libexec/gcc/i386-redhat-linux/4.1.2/cc1plus
	 707639   19416   19444  746499   b6403 /bin/bash

###存储器分配

关于存储器的分配，包括两个区域存储分配，一个是heap一个是stack.对于heap来说， ISO C提供了下面这些函数来分配heap上空间：

-	malloc
-	calloc
-	realloc

这些里面会调用sbrk或者是mmap系统调用，得到内存之后在用户态进行管理。对于sbrk 得到内存free不会释放回去，而调用mmap得到的内存会mumap回去。

对于stack来说，提供了两种方式，一种是函数一种是编译器的语法。函数是alloca而 语法就是varied length array(VLA)(只有gcc支持，g++不支持).

	#include <alloca.h>
	#include <string.h>
	#include <stdio.h>
	
	int main(){
	    //alloca
	    char* p=(char*)alloca(100);
	    strcpy(p,"hello,world");
	    printf("%s\n",p);
	
	    //VLA
	    int len=100;
	    char p2[len];
	    strcpy(p2,"hello,world");
	    printf("%s\n",p2);
	    return 0;
	}

###命令行参数和环境表

对于标准main函数界面应该是这样的：

	int main(int argc,char* argv[],char* envp[]);

通常来说也可以不写第三个参数，而直接使用全局变量引用也可以extern char** environ.其中环境表 每个项的内容都是一个字符串，格式为"name=value",如果用户需要使用的话需要自己进行解析，或者是 使用getenv这样的接口来使用。

关于环境表操作有必要说说。环境表的接口有下面这些：

	char* getenv(const char* name);
	int putenv(const char* str);
	int setenv(const char* name,const char* value,int rewrite);
	int unsetenv(const char* name);

关于putenv和setenv的差别可以看到，因为环境表存放的是name=value这样的表示，而setenv提供的是 k,v单量，所以setenv内部是需要分配一个内存来合并name和value的。

在上一节看到了程序启动时候，参数和环境变量都是安排在内存空间高端的。这就造成一个问题，那就是 如果putenv和setenv需要添加环境表的内容怎么办？事实上这个问题也很好办，原则就是尽可能复用内存：

-	如果改写
	-	如果name=value长度更短，那么覆盖原空间。
	-	如果name=value长度更长，那么开辟新空间替换指针。
-	如果追加
	-	如果环境表项足够，那么开辟name=value并且填写指针。
	-	如果环境表项不够，那么重开一个环境表，然后开辟name=value并且填写指针。

###非局部跳转

局部跳转是指在一个函数内的跳转，可以使用goto.非局部跳转就是指函数之间的跳转了。使用的 函数是：

	#include <setjmp.h>
	int setjmp(jmp_buf env);
	void longjmp(jmp_buf env,int val);

使用方式是，在一个地方setjmp得到当前jmpbuf内容并且返回0,表示第一次调用。如果使用 longjmp并且val!=0的话，那么调回这个位置时候，说明是非局部跳转。

	#include <setjmp.h>
	#include <stdio.h>
	jmp_buf env;
	void foo(){
	    printf("ins 1\n");
	    longjmp(env,1);
	    printf("ins 2\n");
	}
	int main(){
	    int ret=setjmp(env);    
	    if(ret==0){
	        foo();
	    }else if(ret==1){
	        printf("jmp from foo\n");
	    }
	    return 0;
	}
	[dirlt@localhost.localdomain]$ ./main
	ins 1
	jmp from foo

对于非局部跳转的实现，仅仅是保存寄存器的内容。也就是说，如果变量被安排在寄存器上的话， 那么跳回去的时候，值是会回滚的。如果不希望回滚的话，那么就要声明变量是volatile的。 同时也可以看到，因为仅仅保存的是寄存器，所以如果跳转到函数的话，必须保证栈上内容没有被 修改

	#include <setjmp.h>
	#include <stdio.h>
	#include <string.h>
	jmp_buf main_env;
	jmp_buf foo_env;
	void foo(){
	    char stack[16];
	    strcpy(stack,"hello,world");
	    if(setjmp(foo_env)==0){
	        printf("%p,%x\n",stack,(unsigned char)stack[0]);
	    }else{
	        printf("%p,%x\n",stack,(unsigned char)stack[0]);
	        longjmp(main_env,1);
	    }
	}
	void foo2(){
	    char stack[16];
	    strcpy(stack,"hello,dirlt");
	    printf("%s\n",stack);
	}
	int main(){
	    if(setjmp(main_env)==0){
	        foo();
	        foo2();
	        printf("jmp to foo again\n");
	        longjmp(foo_env,1);
	    }else{
	        printf("jmp from foo\n");
	    }        
	    return 0;
	}
	[]$ ./main 
	0xbffc0d28,68
	hello,dirlt
	jmp to foo again
	0xbffc0d28,b0
	jmp from foo

可以看到调用foo2之后企图重新进入foo的话，结果是stack变量修改了。

###资源限制

每个进程都有一组资源限制，可以设置和查看这些资源限制。

	#include <sys/resource.h>
	int getrlimit(int resource,struct rlimit* limit);
	int setrlimit(int resource,const struct rlimit* limit);
	struct rlimit{
	    rlim_t rlim_cur; //soft limit,current limit.
	    rlim_t rlim_max; //hard limit,maximum value for rlim_cur.
	};

对于资源限制分为硬限制和软限制，遵循下面三个规则：

-	任何进程都可以将软限制调整<=硬限制。
-	任何进程可以降低硬限制，但是必须>=软限制。
-	只有超级用户可以提高硬限制。

常量RLIMINFINITY可以指定无限量限制。

关于resoruce有下面这几个常量：

常量	说明
	RLIMITAS	进程可用存储区最大总长度，影响sbrk和mmap
	RLIMITCORE	core文件最大字节数
	RLIMITCPU	CPU使用的最大值，单位秒
	RLIMITDATA	数据段最大值，包括初始化未初始化数据和堆总和
	RLIMITFSIZE	可以创建文件最大字节数，如果超过限制发送SIGXFSZ信号
	RLIMITLOCKS	进程持有的文件锁最大数
	RLIMITMEMLOCK	使用mlock锁定的最大字节长度
	RLIMITMSGQUEUE	message queue允许分配的最大字节数
	RLIMITNICE	进程允许调整到的最高nice value
	RLIMITNOFILE	进程能够打开文件最大数
	RLIMITNPROC	每个实际用户ID可拥有的最大进程数
	RLIMITRSS	最大驻内存的字节长度(resident set size in bytes,RSS)
	RLIMITRTPRIO	每个进程设置的实施优先级的最大值
	RLIMITSIGPENDING	排队信号的最大值
	RLIMITSBSIZE	用户占用的内核socket bufer最大长度
	RLIMITSTACK	栈的最大字节长度
	RLIMITVMEM	和RLIMITAS相同 对于RLIMITCPU来说，超过soft limit每秒发送SIGXCPU信号，如果超过hard limit发送SIGKILL。


	[]$ ulimit -a
	core file size          (blocks, -c) 0
	data seg size           (kbytes, -d) unlimited
	scheduling priority             (-e) 0
	file size               (blocks, -f) unlimited
	pending signals                 (-i) 4096
	max locked memory       (kbytes, -l) 32
	max memory size         (kbytes, -m) unlimited
	open files                      (-n) 1024
	pipe size            (512 bytes, -p) 8
	POSIX message queues     (bytes, -q) 819200
	real-time priority              (-r) 0
	stack size              (kbytes, -s) 10240
	cpu time               (seconds, -t) unlimited
	max user processes              (-u) 4096
	virtual memory          (kbytes, -v) unlimited
	file locks                      (-x) unlimited