---
layout: post
title:  APUE——进程控制
categories: [APUE]
---



###进程标识符

每个进程都有一个表示非负整数的唯一进程ID，但是这个ID是可以重复使用的。 Unix提供采用延迟重用算法，但是如果创建进程频繁的话，那么ID很快就会被重复使用。

在系统中有一些专用的进程。ID==0的进程通常是调度进程(swapper)是内核一部分， 并不执行任何磁盘上的程序，ID==1的进程是init进程，在自举过程结束时由内核调用， 负责在自举内核后启动一个Unix系统，早期版本是/etc/init较新版本是/sbin/init. 会读取/etc/rc*和/etc/inittab以及/etc/init.d中的文件，然后将系统引入一个状态。 ID==2是页守护进程(page daemon),负责支持虚拟存储系统的分页操作。

进程标识符接口有下面这些：

	getpid //pid
	getppid //parent pid
	getuid //实际用户id
	geteuid //有效用户id
	getgid //实际组id
	getegid //有效组id


###开辟子进程

我们使用fork/vfork可以开辟子进程：

	#include <unistd.h>
	//返回值==0表示子进程，>0表示父进程(表示子进程pid)
	pid_t fork();
	pid_t vfork();

fork之后，子进程和父进程各自执行自己的逻辑。刚分开的时候，两者的内存映像是相同的。 系统在实现的时候，并没有完全进行复制，而是使用COW(copy on write)的技术来解决的。 如果父子进程任意一个试图修改这些内存的话，那么会对修改页创建一个副本。对于POSIX 线程来说，fork的子进程之后包含了该fork出来的线程，而不是拥有所有线程的副本。

fork失败的原因通常有下面两种：

-	系统中已经存在太多的进程。
-	实际用户ID的进程总数已经超过了系统限制，CHILDMAX.

fork出的子进程继承了父进程下面这些属性：

-	uid,gid,euid,egid
-	附加组id,进程组id,会话id
-	设置用户id标记和设置组id标记
-	控制终端
-	当前工作目录/根目录
-	文件模式创建mask
-	文件描述符的文件标志(close-on-exec)
-	信号屏蔽和安排
-	存储映射
-	资源限制

下面是不同的部分：

-	pid不同
-	进程时间被清空
-	文件锁没有继承
-	未处理信号被清空

fork通常一种使用方法就是之后执行exec程序，因为大部分时候做一个COW内存映像也是没有必要的。 vfork相对于fork就是这样一个差别，vfork子进程和父进程占用同一个内存映像，在子进程修改会影响父进程。 同时只有在子进程执行exec/exit之后才会运行父进程。

	#include <sys/types.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <stdlib.h>
	int main(){
	    int env=0;
	    pid_t pid=vfork();
	    if(pid==0){
	        env=1;
	        sleep(2);
	        exit(0);
	    }else{ //parent
	        printf("parent are waiting...\n");
	        printf("%d\n",env);        
	        return 0;
	    }
	}
	[]$ ./main 
	parent are waiting...
	1

实际上子进程占用的栈空间就是父进程的栈空间，所以需要非常小心。如果vfork的子进程并没有 exec或者是exit的话，那么子进程就会执行父进程直到程序退出之后，父进程才开始执行。而这个 时候父进程的内存已经完全被写坏：

	#include <sys/types.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <stdlib.h>
	int main(){
	    int env=0;
	    pid_t pid=vfork();
	    if(pid==0){
	        env=1;
	        return 0;
	    }else{ //parent
	        printf("parent are waiting...\n");
	        printf("%d\n",env);        
	        return 0;
	    }
	}
	[]$ ./main 
	parent are waiting...
	6616584
	Segmentation fault

###exit函数

库函数调用exit最终调用exit函数时候，会关闭所有打开的文件描述符，并且释放它所使用 的存储器。exit函数参数是退出状态，然后内核会转换成为终止状态交给父进程来进行处理。

如果父进程在子进程之前结束的话，那么内核如何将终止状态传回给父进程呢？这个时候子进程 已经没有父进程成为了孤儿进程。对于孤儿进程，内核会修改这个进程的父进程为init进程，操作 过程大致如下：每当一个进程终止时，内核会逐个检查所有活动进程，以判断它是否需要是正要 终止进程的子进程，如果是的话，那么修改ppid=1.

	#include <sys/types.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <stdlib.h>
	int main(){
	    int env=0;
	    pid_t pid=fork();
	    if(pid==0){
	        sleep(2);
	        printf("%d\n",getppid());
	    }else{ //parent
	    }
	    return 0;
	}
	[]$ ./main 
	[]$ 1

另外一个情况是，如果子进程在父进程之前结束，父进程如何来获得子进程的终止状态呢？ 内核为每个终止子进程保存了一定的信息，父进程调用wait/waitpid就可以获得这些信息，包括进程 ID,终止状态以及占用CPU时间。对于一个终止但是父进程尚未进行处理的子进程，成为僵死 进程(zombie).而如果子进程变成孤儿进程由init托管后，是不会发生僵死进程的，因为init内部 会通过wait来处理。

	+#include <sys/types.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <stdlib.h>
	int main(){
	    //创建僵死进程10个
	    int i=0;
	    for(i=0;i<10;i++){
	        if(fork()==0){
	            //child exit
	            exit(0);
	        }else{
	            continue;
	        }
	    }
	    //在这个时候挂起使用ps aux查看
	    getchar();
	    return 0;
	}
	dirlt     9472  0.0  0.1   1604   300 pts/0    T    17:04   0:00 ./main
	dirlt     9473  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9474  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9475  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9476  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9477  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9478  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9479  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9480  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9481  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>
	dirlt     9482  0.0  0.0      0     0 pts/0    Z    17:04   0:00 [main] <defunct>


###等待子进程结束

当一个进程正常或者是异常终止的时候，内核就会向父进程发送一个SIGCHLD信号，父进程可以对 这个信号进行处理或者是忽略，默认情况下面是忽略。如果父进程需要处理的话，那么就可以调用 wait/waitpid来得到子进程终止状态。

两个函数接口是：

	#include <sys/wait.h>
	pid_t wait(int* statloc);
	pid_t waitpid(pid_t pid,int* statloc,int options);

行为是这样的：

-	如果没有任何子进程结束，那么默认阻塞。
-	如果任一子进程终止的话，那么父状态得到这个子进程终止状态返回，而子进程资源可以回收。
-	如果没有任何子进程的话，那么出错返回。

对于waitpid是wait的升级版本，可以选择非阻塞返回，并且可以等待一个特定的子进程返回， 而不是只是等待第一个结束的子进程返回。

对于pid来说：

-	==-1.任意子进程
-	>0.pid和pid相等的子进程
-	==0.组id和调用进程组id相同的任一子进程
-	<0.组id等于pid的任一子进程

这个关系到进程组的概念，后面会提到。

对于statloc如果不为NULL的话，那么可以获得子进程终止状态，通过宏来处理这个值：

宏	说明

WIFEXITED	说明子进程正常终止，用WEXITSTATUS得到子进程调用exit返回值的低8位

WIFSIGNALED	接到一个信号终止，终止信号可以通过WTERMSIG获得，是否产生core可以通过WCOREDUMP获得

WIFSTOPPED	如果实现作业控制，子进程暂停，通过WSTOPSIG可以获得让子进程暂停的信号，配合WUNTRACED使用

WIFCONTINUED	如果实现作业控制，子进程继续执行。配合WCONTINUED使用 这里关系到作业控制概念，后面会提到。

对于options有下面几个值：

-	WCONTINUED.
-	WUNTRACED.
-	WNOHANG.非阻塞的等待子进程结束。

之前提到了对于子进程结束的话，内核是会维护子进程的一些资源使用和终止状态的。对于wait/waitpid来说，只是 得到了终止状态信息，如果需要得到资源使用的饿话，那么可以使用wait3/wait4函数。这两个函数都是wait/waitpid 的升级版本。

	pid_t wait3(int* statloc,int options,struct rusage* rusage);
	pid_t wait4(pid_t pid,int* statloc,int options,struct rusage* rusage);


###exec函数

exec函数并不创建任何新进程，所以前后进程关系是没有发生任何改变的。exec所做的事情就是替换当前 正文段，数据，堆和栈。exec族函数包括：

	int execl(const char* pathname,const char* arg0,...); //end with NULL
	int execv(const char* pathname,char* const argv[]); //end with NULL
	int execle(const char* pathname,const char* arg0,...);//end with NULL and char* const envp[]
	int execve(const char* pathname,char* const argv[],char* const envp);
	int execlp(const char* filename,const char* arg0,...); //end with NULL
	int execvp(const char* filename,char* const argv[]); //end with NULL

对于exec来说，如果传入的是filename的话，那么：

-	如果包含/的话，那么认为这是一个路径名pathname
-	否则在PATH环境变量里面查找到第一个可执行文件
-	如果可执行文件不是链接器产生的话，那么认为是一个shell文件，使用/bin/sh执行


执行exec函数，下面属性是不发生变化的：

-	进程ID和父进程ID
-	实际用户ID和实际组ID
-	附加组ID
-	会话ID
-	控制终端
-	闹钟余留时间
-	当前工作目录
-	根目录
-	umask
-	文件锁
-	进程信号屏蔽
-	未处理信号
-	资源限制
-	进程时间


而下面属性是发生变化的：

-	文件描述符如果存在close-on-exec标记的话，那么会关闭。
-	如果可执行程序存在设置用户ID和组ID位的话，那么有效用户ID和组ID会发生变化。


###更改用户ID和组ID

所涉及的函数包括下面几个：

	#include <unistd.h>
	int setuid(uid_t uid);
	int setgid(gid_t gid);
	//r for real,e for effective
	int setreuid(uid_t ruid,uid_t euid);
	int setregid(gid_t rgid,gid_t egid);
	int seteuid(uid_t uid);
	int setegid(gid_t gid);

组id和用户id在处理逻辑上面是等价的，所以这里只是说说对于uid的处理。

这里有必要说说保存设置用户ID的作用。保存设置用户ID判断是否存在是用过SCSAVEDIDS这个 选项来判断的。假设我们编写一个程序aaa,用户是dirlt,然后aaa的owner是root并且设置了设置uid位。 当我们exec这个aaa程序的话，我们ruid=dirlt,euid=root.因为ruid=dirlt,euid=root，那么如果进行 下面这样的操作的话seteuid(dirlt)修改有效用户id为dirlt是允许的，因为ruid就是dirlt. 这样ruid=dirlt,euid=dirlt.这样就造成了一个问题，如果我们想设置回来root系统如何验证呢？ 系统不可能再去读取一次文件系统，所以要求内核本身就保存一个设置用户id.可以看到设置用户id 通常保存的内容就是第一次exec文件使用的euid.

对于setuid(uid)行为是这样的：

-	如果是超级用户进程的话，那么ruid=uid,euid=uid,savedid=uid.
-	如果不是超级用户进程的话，如果uid==实际用户id或者是保存设置id的话，那么euid=uid.
-	出错那么返回-1并且errno=EPERM.

id	exec但是设置用户ID关闭	exec设置用户ID打开	setuid(uid)超级用户	setuid(uid)非特权用户

ruid	不变	不变	uid	不变

euid	不变	文件owner uid	uid	uid

savedid	euid	euid	uid	不变 对于setreuid不是很了解，对于seteuid来说和setuid差别不大，只不过超级用户也只是修改euid.

###system函数

system函数使用起来非常方便，但是需要了解其中细节才可能用好。system本身实现大致就是

-	fork/exec
-	使用命令/bin/sh -c来执行cmdstring
-	父进程使用waitpid得到结果

对于system的返回值有下面三种：

-	如果fork或者是waitpid返回除EINTR之外的错误，那么返回-1并且设置errno
-	如果exec失败的话，那么/bin/sh返回值相当执行exit(127).
-	如果都成功的话，那么返回命令的终止状态。

因为cmdstring是通过/bin/sh来执行的话，那么允许里面包含glob符号和重定向等shell字符。

值得一提的是，在waitpid出来之前，system使用wait函数来等待子进程返回，方式大概如下：

	while((lastpid=wait(&status))!=pid && lastpid!=-1);

那么如果在system之前执行了一个子进程S，然后system启动。这在system的cmdstring之前 子进程S返回的话，那么相当于这个状态是丢弃的了。当system执行完毕之后，父进程 在外面wait子进程S的话，就会阻塞住，因为子进程S已经处理并且丢弃了。所以需要使用waitpid 这种有选择的等待子进程结束的方式。

还有需要注意的是，如果执行system的进程有效用户ID是0(root)的话，执行一个X没有设置设置uid 和gid位的话，因为system没有调用setuid和setgid接口，会导致X的有效用户ID是0(root)，因此在 使用system的时候需要特别小心。原理是：

	//main.cc
	#include <cstdio>
	#include <cstdlib>
	int main(int argc,char* const argv[]){
	    system(argv[1]);
	    return 0;
	}
	
	//echo.cc
	#include <unistd.h>
	#include <cstdio>
	int main(){
	    printf("ruid=%d,euid=%d\n",getuid(),geteuid());
	    return 0;
	}
	[]$ su root
	口令：
	[root@localhost doc]# chown root:root main
	[root@localhost doc]# chmod +s ./main
	[root@localhost doc]# ll
	总计 536
	-rw-r--r-- 1 dirlt dirlt  38697 05-24 06:52 Announce.org
	-rw-r--r-- 1 dirlt dirlt 129914 05-24 15:48 APUE.html
	-rw-r--r-- 1 dirlt dirlt  85116 05-26 09:33 APUE.org
	-rw-r--r-- 1 dirlt dirlt  32766 04-19 16:36 BuildSystem.org
	-rw-r--r-- 1 dirlt dirlt  12362 12-27 12:48 DesignPattern.org
	-rwxr-xr-x 1 dirlt dirlt   5467 05-26 09:30 echo
	-rw-r--r-- 1 dirlt dirlt    396 05-26 09:29 echo.cc
	-rw-r--r-- 1 dirlt dirlt   4849 04-19 16:43 Encoding.org
	-rw-r--r-- 1 dirlt dirlt   5370 04-20 19:22 GCCAssembly.org
	-rw-r--r-- 1 dirlt dirlt   2343 04-25 11:07 GDB.org
	-rw-r--r-- 1 dirlt dirlt  13423 03-09 08:47 HTML.org
	-rw-r--r-- 1 dirlt dirlt   9021 04-26 11:58 Investment.org
	-rwsr-sr-x 1 root  root    5254 05-26 09:33 main
	-rw-r--r-- 1 dirlt dirlt    391 05-26 09:28 main.cc
	-rw-r--r-- 1 dirlt dirlt    602 04-25 11:07 MultiThread.org
	-rw-r--r-- 1 dirlt dirlt   9110 05-19 09:23 OProfile.org
	-rw-r--r-- 1 dirlt dirlt   8310 04-25 11:07 PrinciplesOfEconomics.org
	-rw-r--r-- 1 dirlt dirlt   9534 04-26 12:02 PurchaseHouse.org
	-rw-r--r-- 1 dirlt dirlt   6617 05-17 07:30 RentHouse.org
	-rw-r--r-- 1 dirlt dirlt  24906 04-16 18:29 SIMD.org
	[root@localhost doc]# exit
	exit
	[]$ ./main  ./echo
	ruid=500,euid=500 //实际上这里并没有改变。如果按照上面阐述的话，应该euid=0
	[dirlt@localhost.localdomain]$ 

对于bash2以上版本修复了这个问题。回想一下system调用的是/bin/sh这个命令，如果 /bin/sh发现有效用户和实际用户不匹配的话，会将有效用户设置成为实际用户。

为了验证另外一种情况

	//main.cc
	#include <cstdio>
	#include <cstdlib>
	#include <sys/types.h>
	#include <sys/wait.h>
	#include <unistd.h>
	int main(int argc,char* const argv[]){
	    pid_t pid=fork();
	    if(pid==0){
	        execlp(argv[1],argv[1],NULL);
	    }else{
	        waitpid(pid,NULL,0);
	    }
	    return 0;
	}
	[]$ su root
	口令：
	[root@localhost doc]# chown root:root main
	[root@localhost doc]# chmod +s main
	[root@localhost doc]# exit
	exit
	[]$ ./main ./echo
	ruid=500,euid=0 //这个时候就修改成功了
	[]$ 

###解释器文件

解释器文件是以#!开头的文件，格式是

	#!pathname [optional-arguments]

假设文件是X,我们正准备执行./X arg0 arg1.那么shell会做如下处理：

识别出是解释器文件X

直接调用pathname [optional-arguments] X arg0 arg1

	#include <cstdio>
	int main(int argc,char* const argv[]){
	    for(int i=0;i<argc;i++){
	        printf("%s\n",argv[i]);
	    }
	    return 0;
	}
	#!./main hello world
	[]$ ./shell arg0 arg1
	./main
	hello world
	./shell
	arg0
	arg1

使用解释器文件有下面这些好处。首先是隐藏内部细节。如果文件是python编写的话， 但是执行起来并没有调用python.对于用户来说就是一个可执行文件。其次和效率相关， 假设对于下面这个例子的两种写法：

	#!/usr/bin/env python
	print("hello,world")
	/usr/bin/env python -c 'print("hello,world")'

前面一种是解释器写法，后面一种是非解释器写法。对于非解释器文件来说，如果使用./X 来执行的话，那么经过下面这几个步骤：

shell尝试执行./X.(execlp)但是失败，发现这个是一个shell脚本文件。

那么会尝试启动/bin/sh来将这个文件作为输入，执行文件内容。

可以看到相比较解释器文件的话，首先execlp会尝试判断是否为shell脚本，这个部分会试错， 同时试错之后还要启动一个/bin/sh来执行shell脚本。另外一点可以看到，实际上我们 是最终拿/bin/sh来执行shell脚本的，问题是如果我们shell脚本中使用了一些其他shell 脚本特性的话，那么就会fail:(.

###用户标识

如果多个用户对应同样一个uid的话，那么我们这个时候就没有办法区分用户了。Unix系统 提供下面这个函数来得到登陆用户。如果调用此函数的进程没有连接到用户登录所使用 的终端的话，那么本函数会失败。通常来说这些进程就是守护进程daemon.

	#include <unistd.h>
	char* getlogin();

###进程时间

使用下面函数可以获得进程执行时间：

	#include <unistd.h>
	struct tms {
	    clock_t tms_utime;  /* user time */
	    clock_t tms_stime;  /* system time */
	    clock_t tms_cutime; /* user time of children */
	    clock_t tms_cstime; /* system time of children */
	};
	clock_t times(struct tms* buf); //返回wall clock time.但是需要通过差值来反映

为了转换成为秒数，需要使用sysconf(SCCLKTCK)得到每秒钟多少个滴答数。