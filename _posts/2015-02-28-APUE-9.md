---
layout: post
title:  APUE——进程关系
categories: [APUE]
---

关于进程关系会涉及到进程组和会话，以及和会话相关的控制终端等话题。这里我们主要关注几个概念， 在实际编写代码时候，我们很少去自己管理会话和控制终端，而这些问题是shell需要面对的。历史的shell 有些是不支持会话的，但是现在基本上shell都支持会话，所以我们这里也只是以支持会话的shell为例。

###登录过程


首先看看终端登录过程，这个过程是BSD的，但是Linux基本相同：



1. 管理员创建/etc/ttys文件，每个终端设备有一行表明设备名和getty启动参数。
2. 系统自举创建init进程，init进程读取/etc/ttys文件，对每个终端fork并且exec gettty.
3. getty打开终端设备，这样就映射到了文件描述符0,1,2.然后初始化环境，exec login.
4. login基本功能就是读取用户密码，然后验证。如果失败的话，那么直接退出。
5. 失败的话，那么init会接收到失败的信号，然后重新fork一个getty出来。
6. 如果login成功的话，那么会执行下面这些动作：
	-	更改目录为当前用户home目录
	-	chown终端权限所有权，使登录用户为所有者
	-	将终端设备访问权限修改称为用户读写
	-	调用setgid和initgroups设置进程的组id
	-	设置环境变量，然后exec shell

bash启动之后会读取.bashprofile.这样用户最终的话，通过终端连接到终端设备驱动程序， 而终端设备的读写被映射成为0,1,2文件描述符被shell使用。用户操作终端的话，会被终端设备驱动程序接收到， 而对于shell来说，这些操作就是直接从0,1,2读取和写入数据。对于Linux来说，唯一不同的就是，对于 gettty启动过程参数不是在文件/etc/ttys而是在/etc/inittab里面描述的。

	| shell | 终端设备驱动程序 | 用户 |

网络登录基本上和终端登录相同。不过init进程并不一开始就开辟多个getty进程，因为通过网络进程没有办法 估计有多少个用户登录，同时需要处理网络传输。init进程启动的是inted这个进程，inted监听某些登录端口， 假设用户通过telnet登录，inetd监听23端口。如果用户请求到达的话，那么会启动一个telnetd这个服务，好比getty, 只不过telnetd连接的是一个伪终端设备驱动程序，但是文件描述符依然是0,1,2.但是telnetd并不会直接exec login. 因为如果login执行失败的话，那么没有办法重新启动telnetd(注意现在login失败的话，那么父进程是init而不是telnetd). 所以telnetd通过fork一次，子进程exec login.如果子进程失败的话，那么父进程可以感知到。如果成功的话，那么和终端登录一样。

	| shell | 伪终端设备驱动程序 | 用户 |

###进程组

进程组是一个或者是多个进程的集合，通常和一个作业相关联，可以接受来自同一终端的各种信号。每个进程组有一个唯一的进程组ID, 也有一个组长进程，组长进程标识是组长进程id==进程组id.或者进程组id可以通过

	pid_t getpgrp();
	pid_t getpgid(pid_t pid); //如果pid==0,那么就是调用进程进程组id

进程组的存在和进程组长是否终止没有关系，进程组的生命周期是最后一个进程消亡或者是离开了进程组。

也可以使用

	int setpgid(pid_t pid,pid_t pgid);

将pid的进程组id设置为pgid.pid==0的话，那么使用调用进程的pid,如果pgid==0的话，那么将pid设置为pgid.

###会话

会话是一个或者是多个进程组集合。进程可以通过调用

	pid_t setsid();

来建立一个新会话。如果调用此函数的进程不是进程组长的话，那么就会创建一个新的会话。那么此时会：

-	该进程称为会话首进程(session leader).
-	该进程称为进程组组长.
-	该进程没有控制终端，即使之前有控制终端那么这种联系也会断掉。

我们使用第三个特性来创建daemon进程。调用getsid可以获得会话首进程进程组pid,也就是会话首进程进程id.

###控制终端

会话和进程组有一些其他特性，包括下面这些：

-	一个会话持有一个控制终端(controlling terminal)，可以是终端设备也可以是伪终端
-	建立与控制终端连接的会话首进程被称为控制进程(controlling process).
-	一个会话有多个进程组，允许存在多个后台进程组(backgroup process group)和一个前台进程组(foregroup process group).
-	键入终端的中断键(Ctrl+C)会发送中断信号给前台进程组所有进程。
-	键入终端的退出键(Ctrl+\)会发送退出信号给前台进程组所有进程。
-	终端或者是网络断开的话，那么会将挂断信号发送给会话首进程。

通常来说我们不必关心控制终端，因为在登录shell时候已经自动建立控制终端了。

查看当前shell使用的控制终端可以

	[]$ ps
	  PID TTY          TIME CMD
	23449 pts/18   00:00:00 bash
	13311 pts/18   00:00:12 emacs
	25278 pts/18   00:00:00 ps

通过控制终端可以设置前台进程组和获取前台进程组信息，以及获取会话首进程。设置了前台进程组的话， 这样终端设备驱动程序就可以知道终端输入和输出信号送到何处了。

	pid_t tcgetpgrp(int fd);
	int tcsetpgrp(int fd,pid_t pgrpid);
	pid_t tcgetsid(int fd);
通常我们并不调用这些函数，作业控制通常交给shell来控制。这里fd必须引用的是控制终端。 通常来说在程序启动时候，0,1,2就引用了。

###作业控制

作业控制是在BSD后期版本加入的，允许一个终端上启动多个作业(进程组),控制哪一个作业可以访问该终端， 以及哪些作业是在后台运行的。作业控制我们大体接触到这些信号：

	SIGTSTP(Ctrl+Z)
	SIGINT(Ctrl+C)
	SIGQUIT(Ctrl+\)
	SIGHUP(终端断开或者是网络断开)
	SIGCONT(fg,将后台进程组切换到前台进程组)
	SIGTTIN
	SIGTTOUT

这几种信号之间会有交互作用，比如对一个进程产生四种停止信号(SIGTSTP,SIGSTOP,SIGTTIN,SIGTTOUT)那么就会 取消SIGCONT信号，而产生SIGCONT信号的话也会丢弃停止信号。

这里主要说说SIGTTIN和SIGTTOUT信号。如果一个后台进程组尝试读取控制终端的话，那么会产生一个SIGTTIN信号。 后台作业会停止，shell检测到后台作业状态发生变化的话，那么通知我们作业停止。同样如果准备写控制终端的话， 会产生SIGTTOUT信号，后台作业也会停止我们被通知到。不过大部分情况是，作业会直接写到终端上， 而之后shell会显示后台作业运行完毕。我们可以稍微调整一下控制终端行为，就可以看到这样的结果：

	[]$ cat >tmp.txt &
	[2] 30493 //挂起
	[]$ 
	
	[2]+  Stopped                 cat >tmp.txt //显示停止
	[]$ 
	[]$ cat tmp.txt &
	[2] 30617
	[]$ hello,world
	
	[2]-  Done                    cat tmp.txt
	[]$ stty tostop
	[]$ cat tmp.txt &
	[2] 30643
	[]$ 
	
	[2]+  Stopped                 cat tmp.txt
	[]$ fg
	cat tmp.txt
	hello,world
	[]$ 

如果我们使用设置前台进程组函数的话，那么一样可以看到这样的情况

	#include <unistd.h>
	#include <signal.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	
	int main(){
	    tcsetpgrp(STDIN_FILENO,getppid());
	    char ch;
	    read(STDIN_FILENO,&ch,sizeof(ch));
	    return 0;
	}

因为getppid()为shell的pid,当设置为前台进程的话我们继续从stdin读取的话，那么就会产生SIGTTIN信号， 然后stop掉，通知到父进程shell.然后shell告诉我们子进程停止了

	[dirlt@localhost.localdomain]$ ./a.out 
	
	[2]+  Stopped                 ./a.out
	[dirlt@localhost.localdomain]$ fg
	./a.out
	x
	[dirlt@localhost.localdomain]

###孤儿进程组

孤儿进程组定义为：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。 如果某个进程终止，使得某个进程组成为孤儿进程组的话，系统会向孤儿进程组里面每个处于停止状态进程发送一个SIGHUP信号， 然后发送SIGCONT信号。

	#include <unistd.h>
	#include <signal.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	
	static void sig_hup(int signo){
	    printf("SIGHUP received,pid=%d\n",getpid());
	}
	static void pr_ids(const char* name){
	    printf("%s:pid=%d,ppid=%d,pgrp=%d,tpgrp=%d\n",
	           name,getpid(),getppid(),getpgrp(),tcgetpgrp(STDIN_FILENO));
	}
	int main(){
	    pr_ids("parent");
	    pid_t pid;
	    if((pid=fork())==0){//child
	        pr_ids("child");
	        signal(SIGHUP,sig_hup);
	        //sleep(5);
	        kill(getpid(),SIGTSTP);
	        pr_ids("child");
	        char c;
	        if(read(STDIN_FILENO,&c,sizeof(c))==-1){
	            printf("read from tty error,errno=%m\n");
	        }
	        exit(0);
	    }else{
	        //wait the child to install signal handler and send signal
	        sleep(3);
	        exit(0);
	        printf("parent exit\n");
	    }
	}
	[]$ ./a.out 
	parent:pid=26510,ppid=23449,pgrp=26510,tpgrp=26510
	child:pid=26511,ppid=26510,pgrp=26510,tpgrp=26510
	SIGHUP received,pid=26511 //确实接收到了
	child:pid=26511,ppid=1,pgrp=26510,tpgrp=26510 
	//但是SIGCONT被换到了前台进程了,所以tpgrp还是26510并且可读

如果我们这里不kill而是sleep,那么不会接收到SIGHUP信号。然后父进程作为进程组完成之后，前台进程切换到shell了， 这样造成read会存在错误。

	[]$ ./a.out 
	parent:pid=27218,ppid=23449,pgrp=27218,tpgrp=27218
	child:pid=27219,ppid=27218,pgrp=27218,tpgrp=27218
	[]$ child:pid=27219,ppid=1,pgrp=27218,tpgrp=23449 //tpgrp为23449是shell的pid
	read from tty error,errno=Input/output error
	
	[]$