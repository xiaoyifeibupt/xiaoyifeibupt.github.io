---
layout: post
title:  APUE——信号处理
categories: [APUE]
---

Unix早期版本就提供了信号机制，但是这些系统提供的信号模型并不可靠。信号可能丢失，并且可能存在临界情况。 之后Unix版本提供了可靠的信号机制并且提供了信号的原子操作。需要注意的是，这节的信号函数都是和进程先关的， 对于线程来说提供了另外一套信号函数。

###信号概念

信号定义在头文件<signal.h>里面并且都是正整数，没有为0的信号。但是kill对于信号0有着特殊应用。信号出现 情况有下面这些：

-	用户在控制终端按键
-	硬件异常产生信号
-	kill
-	某种条件发生，比如SIGPIPE

信号是一个异步事件，我们不能够再某个点判断信号是否发生，而只能够告诉系统信号发生了我们应该怎么做：

-	忽略信号。但是SIGKILL和SIGSTOP是不可以忽略的，它们向超级用户提供了进程终止和停止的可靠方法。
-	捕捉系统。可以提供自定义函数来处理信号发生动作，但是不能够捕捉SIGKILL和SIGSTOP这两个信号。
-	执行系统默认动作，大多数系统默认动作是终止进程。


###常见信号

	名字	说明	默认	其他
	SIGABRT	异常终止(abort)	终止+core	
	SIGALRM	超时(alarm)	终止	
	SIGBUS	硬件故障	终止+core	
	SIGCHLD	子进程状态改变	忽略	
	SIGCONT	使得暂停进程继续	继续	
	SIGEMT	硬件故障	终止+core	
	SIGFPE	算术异常	终止+core	
	SIGHUP	链接断开	忽略	
	SIGILL	非法硬件指令	终止	
	SIGINT	终端中断符	终止	
	SIGIO	异步IO	忽略/终止	
	SIGIOT	硬件故障	终止+core	
	SIGKILL	终止	终止	
	SIGPIPE	写入无读进程管道	终止	
	SIGPOLL	可轮询事件	终止	
	SIGPROF	profile时间超时	终止	
	SIGPWR	电源失效/重启	终止/忽略	
	SIGQUIT	终端退出符	终止+core	
	SIGSEGV	无效内存引用	终止+core	
	SIGSTKFLT	协处理器故障	终止	
	SIGSTOP	停止	暂停	
	SIGSYS	无效系统调用	终止+core	
	SIGTERM	终止	终止	
	SIGTRAP	硬件故障	终止+core	
	SIGTSTP	终端停止符	暂停	
	SIGTTIN	后端读取tty	暂停	
	SIGTTOUT	后端写tty	暂停	
	SIGURG	紧急数据	忽略	
	SIGUSR1	用户自定义1	终止	
	SIGUSR2	用户自定义2	终止	
	SIGVTALRM	虚拟时间闹钟	终止	
	SIGWINCH	终端窗口大小变化	忽略	
	SIGXCPU	超过CPU限制	终止+core/忽略	
	SIGXFSZ	超过文件长度限制	终止+core/忽略	

下面这些条件是不产生core文件的：

进程是设置用户ID或者是设置组ID的，但是程序文件的owner并不是当前用户。

用户没有写当前目录权限。

core文件已经存在并且用户对文件有写权限。

core文件过大超过允许core出大小。

对于SIGCHLD信号来说，如果忽略的话那么不会产生僵尸进程。子进程返回直接丢弃退出状态。 而父进程如果
调用wait的话，那么会等待到最后一个子进程结束，然后返回-1并且errno=ECHILD.

	int main(){
	    //如果加上的话，那么ps aux看不出有任何僵死进程
	    //如果不加上的话，那么存在僵尸进程
	    signal(SIGCHLD,SIG_IGN);
	    pid_t pid=fork();
	    if(pid==0){//child
	        exit(0);
	    }else{
	        for(;;){
	            sleep(5);
	        }
	    }
	    return 0;
	}

对于SIGHUP信号来说，如果终端断开会传递给会话首进程。如果会话首进程终止，也会发送给前台进程组每一个进程。 对于守护进程来说，因为守护进程没有不关系到任何控制终端，所以可以利用这个信号来通知守护进程配置文件发生变化， 需要重新读取等自定义操作。

###不可靠信号

早期的Unix版本提供的信号机制是不可靠的。首先信号可能会丢失。也就是说信号发生但是进程却可能不知道这点。 signal设置信号处理之后，每次都会复位。那么在调用处理函数和安装这段时间内，信号是按照默认方式处理的。

	void sig_handler(int signo){
	    //这个时间片内，SIGUSR1是按照默认程序处理的
	    //而默认处理方式是终止
	    signal(SIGUSR1,sig_handler);    
	}
	
	int main(){
	    signal(SIGUSR1,sig_handler);
	    return 0;
	}

其次对于信号控制能力差，只是提供阻塞和忽略。如果我们想先阻塞完成之后查看有哪些pending的信号，这是满足不了的。

	int flag;
	void sig_handler(int signo){
	    signal(SIGUSR1,sig_handler);
	    flag=1;
	}
	
	int main(){
	    signal(SIGUSR1,sig_handler);
	    flag=0;
	    //我们这里想仅当触发了SIGUSR1才退出
	    while(flag==0){
	        //但是在这个时间片内，触发了SIGUSR1但是却没有被pause处理
	        pause();
	    }
	    return 0;
	}

###中断的系统调用

早期Unix特征是如果进程在执行一个低速的系统调用的时候，如果捕捉到了一个信号的话，那么会返回错误， errno=EINTR.理由是，一旦信号发生的话意味系统发生某些事情，那么是唤醒阻塞的系统调用好机会。

低速的系统调用，主要是针对那种很可能永久阻塞的系统调用，包括：

读写和打开某些类型文件(管道，终端和网络设备等)
pause,wait以及某些ioctl操作
需要注意的是，磁盘文件并不属于低速系统调用范围。

对于存在中断的系统调用来说，我们必须显示处理中断情况写起来就相当恶心：

	again:
	    if((n=read(fd,buf,BUFFSIZE))<0){
	        if(errno==EINTR){
	            goto again;
	        }
	        //handle error
	    }

为此4.2BSD引入了自动重启系统调用这个概念，不必处理被中断的系统调用。因为自动重启也可能带来问题， 所以4.3BSD允许进程基于每个信号来禁用自动重启功能。Linux系统默认也是自动重启，也支持基于信号来禁用自动重启。

###可重入函数

假设我们正在执行函数A,而正在这个时候出发了信号处理函数，里面也调用了A.我们必须确保两次调用A的结果都完全正确。 如果保证调用完全正确的话，那么这个函数就是可重入函数。很明显可重入函数，对应着就是没有使用全局变量的函数。

这里我们需要区分可重入函数和线程安全函数。如果某个函数使用了全局变量，但是在全局变量访问部分保证串行访问的话， 那么这个函数就是线程安全函数。可重入函数必然是线程安全函数，而线程安全函数不一定是可重入函数。

###可靠信号

我们首先看看可靠信号下面存在哪些术语：

-	产生(generation).当系统认为某个时间时候，那么向进程通知这个信号发生。
-	递送(delivery).当信号处理函数被调用时候，那么说向进程递送了这个信号。
-	未决(pending).信号产生和信号递送这段时间，信号是未决的。
-	阻塞(blocking).进程屏蔽某个信号，并且处理方式不是忽略的话，那么信号会一直保持未决状态。直到更改为忽略处理方式，或者是不屏蔽。
-	排队(queue).阻塞时候如果对应信号发生多次的话，那么信号会累加。不过大部分系统而言Unix并不排队，而只是保存一次。
-	递送顺序(delivery order).系统并没有规定如果多个信号发生，那么哪个信号会首先被递送。但是通常来说是关系到当前进程状态信号被处理，比如SIGSEGV.
-	信号屏蔽字(signal mask)和信号集(sigset).保存多个信号集合。

###信号集

信号集是一堆信号的集合，POSIX.1定义了信号集上一系列操作。因为信号集的数量可能扩展，所以必须定义一个新的结构表示。 但是使用的应该是比较节省的方式，按照bit进行标记。

	//sigset_t as the set of signals
	int sigemptyset(sigset_t* set); //清空
	int sigfillset(sigset_t* set); //填充
	int sigaddset(sigset_t* set,int signo) //添加信号
	int sigdelset(sigset_t* set,int signo) //删除信号
	int sigismember(const sigset_t* set,int signo) //检查是否存在

####sigprocmask/sigpending

sigprocmask可以设置当前信号屏蔽字，sigpending可以返回当前未决信号集。

	#include <unistd.h>
	#include <signal.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	void sig_handler(int signo){
	}
	int main(){
	    sigset_t set;
	    sigemptyset(&set);
	    sigaddset(&set,SIGUSR1);
	    sigaddset(&set,SIGUSR2);
	    signal(SIGHUP,sig_handler);
	    sigprocmask(SIG_BLOCK,&set,NULL);
	    pause();
	    sigpending(&set);
	    printf("pending SIGUSR1=%d\n",sigismember(&set,SIGUSR1));
	    printf("pending SIGUSR2=%d\n",sigismember(&set,SIGUSR2));
	}
	[]$ ./a.out &           
	[2] 6850
	[]$ kill -s SIGUSR2 6850
	[]$ kill -s SIGUSR1 6850
	[]$ kill -s SIGHUP 6850 
	[]$ pending SIGUSR1=1
	pending SIGUSR2=1
	
	[2]-  Done                    ./a.out

####sigaction
sigaction是signal的替代品，但是提供了更多的功能：

	//<sys/ucontext.h>
	typedef struct ucontext{ 
	    unsigned long int uc_flags;
	    struct ucontext *uc_link;
	    stack_t uc_stack;
	    mcontext_t uc_mcontext;
	    __sigset_t uc_sigmask;
	    struct _libc_fpstate __fpregs_mem;
	} ucontext_t;
	
	//<bits/siginfo.h>
	typedef struct siginfo
	  {
	    int si_signo;               /* Signal number.  */
	    int si_errno;               /* If non-zero, an errno value associated with
	                                   this signal, as defined in <errno.h>.  */
	    int si_code;                /* Signal code.  */ //对于这个部分，可以查看sigaction
	
	    union
	      {
	        int _pad[__SI_PAD_SIZE];
	
	         /* kill().  */
	        struct
	          {
	            __pid_t si_pid;     /* Sending process ID.  */
	            __uid_t si_uid;     /* Real user ID of sending process.  */
	          } _kill;
	
	        /* POSIX.1b timers.  */
	        struct
	          {
	            int si_tid;         /* Timer ID.  */
	            int si_overrun;     /* Overrun count.  */
	            sigval_t si_sigval; /* Signal value.  */
	          } _timer;
	
	        /* POSIX.1b signals.  */
	        struct
	          {
	            __pid_t si_pid;     /* Sending process ID.  */
	            __uid_t si_uid;     /* Real user ID of sending process.  */
	            sigval_t si_sigval; /* Signal value.  */
	          } _rt;
	
	        /* SIGCHLD.  */
	        struct
	          {
	            __pid_t si_pid;     /* Which child.  */
	            __uid_t si_uid;     /* Real user ID of sending process.  */
	            int si_status;      /* Exit value or signal.  */
	            __clock_t si_utime;
	            __clock_t si_stime;
	          } _sigchld;
	
	        /* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
	        struct
	          {
	            void *si_addr;      /* Faulting insn/memory ref.  */
	          } _sigfault;
	
	        /* SIGPOLL.  */
	        struct
	          {
	            long int si_band;   /* Band event for SIGPOLL.  */
	            int si_fd;
	          } _sigpoll;
	      } _sifields;
	  } siginfo_t;
	
	struct sigaction{
	    void (*sa_handler)(int); //兼容原来函数
	    sigset_t sa_mask; //信号屏蔽，在处理的时候会屏蔽这些信号，处理完成之后会打开这些信号
	    int sa_flags; //如果当sa_flags里面设置了SA_SIGINFO的话，那么会调用sa_action而不是sa_handler.
	    //其中void*强制转换称为ucontext_t
	    //表示信号传递时进程的上下文
	    //可以看到在siginfo里面有很多信息可用，比如SIGSEGV的话，我们可以看到
	    //造成段错误的具体地址在哪里
	    void (*sa_action)(int,siginfo_t*,void*);
	};
	//signo设置信号，设置新的handler返回老的handler.
	int sigaction(int signo,const struct sigaction* restrict act,struct sigaction* restrict oact);

通常来说我们还是使用sahandler来处理信号。关于saflags我们可以看看选项有哪些：

	选项	说明
	SAINTERRUPT	信号中断的系统调用不会自动重启
	SANOCLDSTOP	如果signo=SIGCHLD的话，子进程停止时不产生此信号，但是终止时会产生
	SANOCLDWAIIT 如果signo=SIGCHLD的话，子进程终止时不创建僵死进程。和将SIGCHLD处理设置为忽略效果相同
	SANODEFER	如果捕捉到此信号，在信号处理时候并不屏蔽这个信号
	SAONSTACK	捕捉到信号时，会将信号传递到使用了sigaltstack替换栈上的进程
	SARESETHAND	捕捉到信号调用处理程序之前，会将信号处理复位
	SARESTART	信号中断的系统调用会自动重启
	SASIGINFO	使用saaction而不是sahandler来处理

####sigsetjmp/siglongjmp
对于setjmp和longjmp并没有规定如何来处理信号屏蔽字。

	int sigsetjmp(sigjmp_buf env,int savemask); //是否保存信号屏蔽字
	int siglongjmp(sigjmp_buf,int val);
	#include <unistd.h>
	#include <setjmp.h>
	#include <signal.h>
	#include <cstdio>
	#include <cstdlib>
	
	jmp_buf env;
	void handler(int signo){
	    longjmp(env,1);
	}
	
	int main(){
	    if(setjmp(env)==1){
	        sigset_t nowmask;
	        sigprocmask(SIG_BLOCK,NULL,&nowmask);
	        printf("SIGUSR1 masked=%d\n",sigismember(&nowmask,SIGUSR1));
	        exit(0);
	    }
	    signal(SIGUSR1,handler);
	    pause();
	    return 0;
	}
	[]$ kill -s SIGUSR1 28591
	SIGUSR1 masked=1
	如果修改称为sig版本的话：
	
	sigjmp_buf env;
	void handler(int signo){
	    siglongjmp(env,1);
	}
	
	int main(){
	    if(sigsetjmp(env,1)==1){
	        sigset_t nowmask;
	        sigprocmask(SIG_BLOCK,NULL,&nowmask);
	        printf("SIGUSR1 masked=%d\n",sigismember(&nowmask,SIGUSR1));
	        exit(0);
	    }
	    signal(SIGUSR1,handler);
	    pause();
	    return 0;
	}
	[]$ kill -s SIGUSR1 29846
	SIGUSR1 masked=0

####sigsuspend
对于pause来说，如果我们还想只是等待某些信号的话，那么就必须这样进行：

-	首先获得当前屏蔽字
-	修改称为我们关心的屏蔽字
-	然后进行pause
-	然后恢复原始屏蔽字

但是在修改屏蔽字和pause之间有一个短暂的时间间隔，如果这个时间信号到来的话，那么pause以后就会永久陷入阻塞。 究其原因是因为这两个操作本来应该为一个操作，应该存在一个原子操作。

	//临时以sigmask替换当前的屏蔽字，然后等待信号到来
	//在等待期间，sigmask设置的信号都是被屏蔽的
	int sigsuspend(const sigset_t* sigmask);

###常用函数

####signal
signal函数是最常见的信号机制相关函数，原型是这样的：

	#include <signal.h>
	typedef void (*SignFunc)(int);
	#define SIG_ERR (SignFunc)-1
	#define SIG_DFL (SignFunc)0
	#define SIG_IGN (SignFunc)1
	SignFunc signal(int signo,SignFunc func);

SignFunc就是信号处理函数，signo就是我们有待关心的信号有哪些。系统提供了几个默认的值， SIGERR表示调用signal错误，SIGDFL表示默认处理函数，SIGIGN表示忽略信号。signal设置完成之后， 就会返回原来的信号处理函数。

	#include <unistd.h>
	#include <signal.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	
	void sig_handler(int signo){
	    printf("%s\n",strsignal(signo));
	}
	
	int main(){
	    signal(SIGUSR1,sig_handler);
	    signal(SIGUSR2,sig_handler);
	    for(;;){
	        sleep(10);
	    }
	    return 0;
	}
	[]$ kill -s SIGUSR1 4742
	[]$ User defined signal 1
	
	[]$ 

程序启动的时候，所有的信号处理方式都是默认的。然后fork来说，因为子进程和父进程的地址空间是一样的，所以信号处理方式保留了下来。 接下来进行exec,会将所有设置成为捕捉的信号都修改成为默认，而原来已经设置成为忽略的信号就不发生改变。

另一个问题就是，对于信号来说如果捕捉到某个信号，进入信号捕捉函数的时候，此时当前信号会自动加入到进程的信号屏蔽字。

	#include <unistd.h>
	#include <signal.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	
	void handler1(int signo){
	    printf("SIGUSR1 received\n");
	    for(;;){
	        sleep(5);
	    }
	}
	
	void handler2(int signo){
	    printf("SIGUSR2 received\n");
	    for(;;){
	        sleep(5);
	    }
	}
	
	int main(){
	    signal(SIGUSR1,handler1);
	    signal(SIGUSR2,handler2);
	    for(;;){
	        sleep(5);
	    }
	    return 0;
	}
	[]$ kill -s SIGUSR1 6473
	[]$ SIGUSR1 received
	
	[]$ kill -s SIGUSR2 6473
	[]$ SIGUSR2 received
	
	[]$ kill -s SIGUSR1 6473 //重复发送没有任何效果
	[]$ kill -s SIGUSR2 6473

如果调用kill为使其为调用者产生信号，并且如果该信号不是被阻塞的话，那么在kill返回之前， 该信号就一定被传送到了该进程并且触发信号捕获函数。

####kill/raise

	#include <signal.h>
	//1.pid>0
	//2.pid==0 发送给属于同一进程组进程，但是不包括系统进程
	//3.pid<0 发送给进程组id==abs(pid)进程，但是不包括系统进程
	//4.pid==-1 发送给所有有发送权限的所有进程
	int kill(pid_t pid,int signo);
	int raise(int signo); //==kill(getpid(),signo)

权限检查是，检查接收者的保存设置id和发送者的实际或者是有效用户id.如果信号是SIGCONT的话， 可以发送给同一个会话里面所有进程。

之前说到signo=0是一种特殊情况，我们可以用来检查进程是否存在，通过发送signo==0的信号。

	#include <unistd.h>
	#include <sys/wait.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	
	int main(){
	    pid_t pid=fork();
	    if(pid==0){
	        exit(0);
	    }else{
	        wait(NULL); //如果没有wait的话，那么存在一个僵死进程
	        sleep(4);
	        if(kill(pid,1)==-1){
	            printf("%m\n");
	        }
	    }
	    return 0;
	}
	[]$ ./a.out 
	No such process
	1.10.8.3 alarm/pause
	#include <unistd.h>
	unsigned int alarm(unsigned int secs);
	int pause();

alarm设置闹钟，如果提前返回的话那么返回剩余时间，同时触发一个SIGALRM信号。如果本次闹钟时间为0的话， 那么取消之前登记的但是尚未超过的闹钟时钟，并且返回上次剩余时间。pause会等待一个信号触发，然后返回-1 并且errno=EINTR.

	#include <unistd.h>
	#include <sys/wait.h>
	#include <signal.h>
	#include <errno.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	void sig_handler(int signo){
	    printf("%s received\n",strsignal(signo));
	}
	int main(){
	    signal(SIGALRM,sig_handler);
	    alarm(5);
	    int ret=pause();
	    printf("%d errno=%m\n",ret);
	    return 0;
	}
	[]$ ./a.out 
	Alarm clock received
	-1 errno=Interrupted system call

####abort

此函数向自身发送SIGABRT信号。如果进程设置了捕获SIGABRT的话，即使从处理函数返回的话，那么仍然不会返回到调用者。 并且POSIX规定该函数并不理会进程对于此信号的阻塞和忽略。让进程捕获SIGABRT的意图是，希望进程终止之前执行所需要的清理操作， 如果进程并不在信号处理中终止自己的话，POSIX声明当信号处理程序返回时，abort终止该进程。

POSIX要求如果abort调用终止进程的话，那么它对所有打开标准IO流的效果应当于进程终止前每个流调用fclose相同。 对于abort内部会调用fflush(NULL)来强制冲洗所有的标准IO流。

当然我们可以使用jmp来绕过abort的部分：

	#include <unistd.h>
	#include <setjmp.h>
	#include <signal.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	
	jmp_buf env;
	void handler(int signo){
	    printf("%s received\n",strsignal(signo));
	    longjmp(env,1);
	}
	
	int main(){
	    if(setjmp(env)==0){
	        signal(SIGABRT,handler);
	        abort();
	    }else{
	        printf("jump frm abort\n");
	        return 0;
	    }
	    return 0;
	}
	[zhangyan@tc-cm-et18.tc.baidu.com]$ ./a.out 
	Aborted received
	jump frm abort

####system

POSIX规定调用system进程需要忽略SIGINT,SIGQUIT信号，阻塞SIGCHLD信号。同时对于返回值来说，如果/bin/sh没有正常执行的话， 那么返回127.如果命令正常执行的话，那么返回命令退出状态。如果/bin/sh因为信号退出的话，那么退出状态时128+信号编号。

	[]$ /bin//bash -c "sleep 30"
	//Ctrl-C发出SIGINT信号，而SIGINT编号为2,所以返回值为130.
	[]$ echo $?
	130

要忽略SIGINT和SIGQUIT信号的原因是因为，如果system执行的是一个交互程序或者是长时间运行程序的话，我们希望能够以 SIGINT或者是SIGQUIT来终止这个程序。但是问题是，如果我们system执行的话，外部调用程序和交互程序都是出于前台进程组的。 如果SIGINT/SIGQUIT信号会发送到前台进程组所有进程，那么外部调用程序和交互程序都会关闭，这不是我们所希望的。

阻塞SIGCHLD信号也是必要的。对于system大体实现是fork/exec/wait来实现的。如果我们不阻塞SIGCHLD而在外部程序安装了 处理SIGCHLD信号的话，那么system执行子进程返回的话，首先会通知捕获程序。如果捕获程序里面调用了wait的话，那么system的 wait就会一直阻塞住了。下面是一个例子来说明这个问题：

	#include <unistd.h>
	#include <sys/wait.h>
	#include <setjmp.h>
	#include <signal.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	
	int pseudo_system(const char* cmd){
	    pid_t pid=fork();
	    if(pid==0){//child
	        sleep(2);
	        exit(0);
	    }else{ //parent
	        printf("parent wait\n");
	        printf("%d exit\n",wait(NULL));
	        printf("parent over\n");
	    }
	    return 0;
	}
	
	void sig_handler(int signo){
	    printf("%s received\n",strsignal(signo));
	    printf("%d exit,%m\n",wait(NULL));
	}
	
	int main(){
	    signal(SIGCHLD,sig_handler);
	    pseudo_system("command");
	    return 0;
	}

但是似乎Linux上面没有这个问题了。相反，一旦发生子进程消亡的情况，如果已经检测到存在wait的话，那么会首先满足 wait,然后在触发SIGCHLD操作。似乎这样做更加合理。

####其他函数

和errno对应的strerror以及perror一样，对于信号也提供了相应的方便打印的函数：

	#include <signal.h>
	void psignal(int signo,const char* msg);
	const char* strsignal(int signo);