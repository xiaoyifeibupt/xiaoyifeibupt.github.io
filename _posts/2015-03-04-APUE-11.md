---
layout: post
title:  APUE——线程和线程控制
categories: [APUE]
---



典型的Unix进程可以看成只有一个控制线程，一个进程在同一个时刻只允许做一件事情。 使用了线程之后，那么一个进程就可以持有多个控制线程，允许做多件事情，这样做有很多好处：

-	为每种事件类型的处理分配单独的线程，这样简化处理异步事件的代码。
-	多个控制线程之间可以共享进程资源，比如内存和文件描述符。
-	多个控制线程可以改善程序的吞吐量，允许多个相互独立的任务交叉运行。
-	交互程序可以显著改善程序的响应时间，用专门线程处理UI专门线程处理后端事情。

对于线程来说，包含了表示进程内执行环境所必须的信息，其中包括：

-	线程ID
-	寄存器堆
-	栈
-	调度优先级和策略
-	信号屏蔽字
-	errno
-	线程私有数据

共享的进程资源主要包括：

-	text段
-	数据段，堆，栈
-	文件描述符

我们使用的是POSIX.1-2001定义的线程接口，pthread or POSIX线程。可以使用POSIXTHREADS/ _SCTHREADS来测试是否支持POSIX线程。

pthread函数在调用失败的时候通常会返回错误码，它们并不像其他的POSIX函数一样设置全局errno。同时每个线程 拥有一个线程局部的errno副本，这样可以和使用了errno的现有函数兼容。

###线程标识

线程使用线程id来标识自己，threadt这个数据结构。我们不能够使用一种可移植的方式来打印该数据类型的值。

	pthread_t pthread_sekf(); //获得自身的线程标识
	int pthread_equal(pthread_t tid1,pthread_t tid2); //比较两个线程号是否相同

###线程创建

创建接口为

	//1.tidp表示创建的线程号
	//2.attr表示线程属性
	//3.线程入口
	//4.线程入口的参数
	int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict attr,void* (*start)(void*),void* restrict arg);

线程创建并不保证那个线程会首先运行，是新创建的线程还是调用线程。新创建的线程可以访问进程的地址空间， 并且集成了线程的浮点环境和信号屏蔽字，但是对于未决的信号都会进行丢弃。

如果希望多个线程里面某些部分只是执行一次的话，可以使用下面这个接口：

	pthread_once_t initflag=PTHREAD_ONCE_INIT;
	int pthread_once(pthread_once_t* initflag,void (*initfn)(void));

然后再每个线程里面调用pthreadonce.下面是一个例子：

	#include <unistd.h>
	#include <pthread.h>
	#include <cstdio>
	#include <cmath>
	#include <cstdlib>
	
	pthread_once_t initflag=PTHREAD_ONCE_INIT;
	void run_once(){
	    printf("just run once\n");
	}
	void* foo(void* arg){
	    pthread_once(&initflag,run_once);
	}
	int main(){
	    pthread_t tid[10];
	    for(int i=0;i<10;i++){
	        pthread_create(tid+i,NULL,foo,(void*)(long)i);
	    }
	    for(int i=0;i<10;i++){
	        pthread_join(tid[i],NULL);
	    }
	    return 0;
	}

###线程终止

如果进程中任意线程调用了exit,Exit,exit的话，或者是任意线程接收到了信号而处理动作是终止的话，那么整个进程就会终止。 对于单个线程只有以下面三种方式退出的话，才可能在不终止整个进程情况下面停止它的控制流：

-	线程只是从启动例程中返回，返回值是线程的退出码。
-	线程可以被同一进程中的其他线程取消。
-	线程调用pthreadexit.

	void pthread_exit(void* ret_ptr); //返回ret_ptr
	int pthread_join(pthread_t tid,void** ret_ptr); //得到ret_ptr内容
	int pthread_cancel(pthread_t tid); //好比调用了pthread_exit(PTHREAD_CANCELED),只是通知线程而并不等待取消，是一个异步过程。
	int pthread_detach(pthread_t tid);

对于pthreadjoin来说，直到指定的tid线程返回那么才返回。如果tid是取消的话，那么retptr是PTHREADCANCELED. pthreadjoin好比wait调用。如果线程是一个detach状态的话，那么pthreadjoin马上就会失败返回EINVAL.

和进程使用atexit一样，线程也允许存在这种清理函数：

	void pthread_cleanup_push(void (*func)(void*),void* arg);
	void pthread_cleanup_pop(int execute); //非0表示立即执行,0表示不立即执行

通常来说这两个函数需要配对使用，因为很可能实现为宏。push包含{,而pop包含}.当线程返回的时候，那么就会触发push的函数：

	void foo(void* arg){
	    printf("%s\n",(char*)arg);
	}
	void* pthread_func(void* arg){    
	    pthread_cleanup_push(foo,(void*)"push1");
	    pthread_cleanup_push(foo,(void*)"push2");
	    for(;;){
	        sleep(5);
	    }
	    pthread_cleanup_pop(0);
	    pthread_cleanup_pop(0);
	    return NULL;
	}
	
	int main(){
	    pthread_t tid;
	    int ret=0;
	    pthread_create(&tid,NULL,pthread_func,0);    
	    ret=pthread_detach(tid);
	    if(ret){
	        printf("pthread_detach:%s\n",strerror(ret));
	    }
	    ret=pthread_join(tid,NULL); //detach之后返回join返回EINVAL错误
	    if(ret){
	        printf("pthread_join:%s\n",strerror(ret));
	    }
	    pthread_cancel(tid);
	    return 0;
	}
	[]$ ./a.out 
	pthread_join:Invalid argument
	push2
	push1

###线程同步

关于线程同步，pthread提供了三种最基本的机制，分别是：

-	互斥锁
-	读写锁
-	条件变量

####互斥锁

互斥锁可以确保同一时间只有一个线程访问数据：

	//可以设置属性
	int pthread_mutex_init(pthread_mutex_t* restrict mutex,
							const pthread_mutexattr_t* restrict attr);
	int pthread_mutex_destroy(pthread_mutex_t* mutex);

对于互斥锁来说可以静态初始化为PTHREADMUTEXINITIALIZER,也可以调用init来进行初始化。

互斥锁操作上有下面几种，包括加锁，解锁和尝试加锁(非阻塞行为):

	int pthread_mutex_lock(pthread_mutex_t* mutex);
	int pthread_mutex_unlock(pthread_mutex_t* mutex);
	int pthread_mutex_trylock(pthread_mutex_t* mutex);

####读写锁

对于部分应用来说是读多写少的应用，而读因为不会修改状态所以是允许读之间并发的。而互斥锁不管是读读之间， 还是读写之间都是会互斥的。读写锁就是用来解决这个问题的：

	//和互斥量不同的是，不允许静态初始化
	int pthread_rwlock_init(pthread_rwlock_t* restrict rwlock,const pthread_rwlockattr_t* restrict attr);
	int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);
	int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
	int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
	int pthread_rwlock_unlock(pthread_rwlock_t* rwlock);
	int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock);
	int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock);

如果在同时有读写请求的话，优先权是交给系统来决定的。当然也有接口可以控制这个行为：

	/* Return current setting of reader/writer preference.  */
	extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
	                                          __restrict __attr,
	                                          int *__restrict __pref)
	     __THROW __nonnull ((1, 2));
	
	/* Set reader/write preference.  */
	extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
	                                          int __pref) __THROW __nonnull ((1));

####条件变量

条件变量允许线程以一种更加友好的协作方式来运行。比如典型的生产和消费者模型来说，如果生产者停滞的话那么 消费者的动作就不断加锁解锁，通过轮训来检测状态会影响到协作性。相反如果生产者当只有生产出东西之后， 再来通知消费者的话，那么性能会更优：

	//如果生产者比消费者速度慢的话，那么大部分时间都在消费者的检查上
	pthread_muext_t mutex;
	void consumer(){
	    pthread_mutex_lock(&mutex);
	    if(has product){
	        //consume something
	    }   
	    pthread_mutex_unlock(&mutex);
	}
	void consumer(){
	    pthread_mutex_lock(&mutex);
	    //produce something
	    pthread_mutex_unlock(&mutex);
	}
	//如果使用条件变量的话，那么大部分空间时间都会在cond_wait上等待，而系统就可以让出CPU
	pthread_muext_t mutex;
	pthread_cond_t cond;
	void consumer(){
	    pthread_mutex_lock(&mutex);
	    pthread_cond_wait(&cond,&mutex);
	    if(has product){
	        //consume something
	    }   
	    pthread_mutex_unlock(&mutex);
	}
	void consumer(){
	    pthread_mutex_lock(&mutex);
	    //produce something
	    pthread_mutex_unlock(&mutex);
	    pthread_cond_signal(&cond);
	}

条件变量会首先判断条件是否满足，如果不满足的话那么会释放当前这个配对的锁，如果一旦触发的话那么会尝试加锁。

关于条件变量接口有下面这些：

	int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_condattr_t* restrict attr);
	int pthread_cond_destroy(pthread_cond_t* cond)
	int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex);
	//有超时时间控制的版本
	int pthread_cond_timewait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex,const struct timespect* restrict timeout);
	//只唤醒一个等待条件变量线程
	int pthread_cond_signal(pthread_cond_t* cond);
	//广播方式进行通知，唤醒所有等待这个条件变量线程
	int pthread_cond_broadcast(pthread_cond_t* cond);

初始化也可以使用PTHREADCONDINITIALIZER来完成。

###线程限制

线程限制有下面这些方面：

	限制名称	描述
	PTHREADDESTRUCTORITERATIONS	线程退出操作系统实现试图销毁线程似有数据的最大次数
	PTHREADKEYSMAX	进程可以创建的键最大个数
	PTHREADSTACKMIN	一个线程可用栈的最小字节数
	PTHREADTHREADSMAX	进程可以创建最大线程数 关于第一个参数后面可以看到为什引入的。键使用来定位线程私有数据的。每个线程都是在特定的可用栈上进行的。

###线程属性

在创建线程的时候我们可以指定线程属性，接口是：

	int pthread_attr_init(pthread_attr_t* attr);
	int pthread_attr_destroy(pthread_attr_t* attr);

对于我们来说，pthreadattrt接口并不是透明的。所以我们设置属性的话是通过其他API来完成的。POSIX.1定义的 线程属性包括下面这些：

名称	描述
detachstate	线程的分离状态属性
guardsize	线程栈末尾的警戒缓冲区大小
stackaddr	线程栈的最低地址
stacksize	线程栈的大小

####分离状态
对于detachstate来说，我们可以控制线程启动时候属性是分离的，还是可以join的。如果我们不设置的话，默认 是joinable的。当然我们也可以使用pthreaddetach来将这个线程属性修改成为分离状态。

	int pthread_attr_getdetachstate(const pthread_attr_t* restrict attr,int* detachstate);
	int pthread_attr_setdetachstate(pthread_attr_t* attr,int detachstate);

其中detachstate为PTHREADCREATEDETACHED或者是PTHREADCREATEJOINABLE.

####线程栈

每个线程都是在特定栈上面运行的，如果我们不设置的话那么会按照默认方式来分配栈。

	int pthread_attr_getstack(const pthread_attr_t* restrict attr,void** restrict stackaddr,size_t* restrict stacksize);
	int pthread_attr_setstack(pthread_attr_t* addr,void* stackaddr,size_t stacksize);

如果我们想修改栈大小但是不想自己控制栈的位置的话，那么pthread提供了一个简化的接口

	int pthread_attr_getstacksize(const pthread_attr_t* restrict attr,size_t* restrict stacksize);
	int pthread_attr_setstacksize(pthread_attr_t* attr,size_t stacksize);

guardsize意思是如果我们使用线程栈超过了设定大小之后，系统还会使用部分扩展内存来防止栈溢出。而这部分扩展内存大小就是guardsize. 不过如果自己修改了栈分配位置的话，那么这个选项失效，效果相当于将guardsize设置为0.

	int pthread_attr_getguardsize(const pthread_attr_t* restrict attr,size_t* restrict guardsize);
	int pthread_attr_setguardsize(pthread_attr_t* attr,size_t guardsize);

不过个人没有看到这个选项有什么特别的好处。

####其他属性
线程还有其他一些属性但是没有在attr里面反应包括：

-	可取消状态
-	可取消类型
-	并发度

并发度控制着用户线程可以映射的内核线程或者是进程数目，如果系统实现多个用户线程对应一个系统线程的话，那么增加 可以运行的用户线程数目可以改善性能。

	int pthread_getconcurrency();
	int pthread_setconcurrency(int level); //如果为0的话那么让用户自己决定

不过这里只是提供接口，系统可以决定是否采用。



###同步属性

####进程共享
对于三个同步机制来说，提供了进程共享的属性。也就是说，如果同步机制是在共享内存上面开辟的话， 并且设置这个同步机制的进程共享属性的话，那么就可以用于进程之间的同步了。

	//互斥量
	/* Initialize mutex attribute object ATTR with default attributes
	   (kind is PTHREAD_MUTEX_TIMED_NP).  */
	extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
	     __THROW __nonnull ((1));
	
	/* Destroy mutex attribute object ATTR.  */
	extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
	     __THROW __nonnull ((1));
	
	/* Get the process-shared flag of the mutex attribute ATTR.  */
	extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
	                                         __restrict __attr,
	                                         int *__restrict __pshared)
	     __THROW __nonnull ((1, 2));
	
	/* Set the process-shared flag of the mutex attribute ATTR.  */
	extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
	                                         int __pshared)
	     __THROW __nonnull ((1));
	
	
	//读写锁
	/* Initialize attribute object ATTR with default values.  */
	extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
	     __THROW __nonnull ((1));
	
	/* Destroy attribute object ATTR.  */
	extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
	     __THROW __nonnull ((1));
	
	/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
	extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
	                                          __restrict __attr,
	                                          int *__restrict __pshared)
	     __THROW __nonnull ((1, 2));
	
	/* Set process-shared attribute of ATTR to PSHARED.  */
	extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
	                                          int __pshared)
	     __THROW __nonnull ((1));
	
	//条件变量
	/* Initialize condition variable attribute ATTR.  */
	extern int pthread_condattr_init (pthread_condattr_t *__attr)
	     __THROW __nonnull ((1));
	
	/* Destroy condition variable attribute ATTR.  */
	extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
	     __THROW __nonnull ((1));
	
	/* Get the process-shared flag of the condition variable attribute ATTR.  */
	extern int pthread_condattr_getpshared (__const pthread_condattr_t *
	                                        __restrict __attr,
	                                        int *__restrict __pshared)
	     __THROW __nonnull ((1, 2));
	
	/* Set the process-shared flag of the condition variable attribute ATTR.  */
	extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
	                                        int __pshared) __THROW __nonnull ((1));

####互斥量类型
对于互斥量来说有一个类型属性，对于互斥量来说有下面4种类型：

	互斥量类型	说明
	PTHREADMUTEXNORMAL	普通锁
	PTHREADMUTEXERRORCHECK	错误锁，同一个线程加锁的话会出现错误
	PTHREADMUTEXRECURSIVE	递归锁，同一个线程加锁的话可以递归加锁
	PTHREADMUTEXDEFAULT	前面三种默认一种，通常为普通锁

函数

	/* Return in *KIND the mutex kind attribute in *ATTR.  */
	extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
	                                      __attr, int *__restrict __kind)
	     __THROW __nonnull ((1, 2));
	
	/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
	   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
	   PTHREAD_MUTEX_DEFAULT).  */
	extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
	     __THROW __nonnull ((1));
我们有下面两种情形需要使用递归锁，我们分别来看看这两个情形。第一个情形下面

	pthread_mutex_t mutex;
	void func1(){
	    pthread_mutex_lock(&mutex);
	    func2();
	    pthread_mutex_unlcok(&mutex);
	}
	
	void func2(){
	    pthread_mutex_lock(&mutex);
	    pthread_mutex_unlcok(&mutex);
	}

如果func1调用了func2,并且func1和func2可以并行执行的话，那么func1调用func2的时候就会锁住。 这样的话，我们不得不提供两个版本func2和func2locked.虽然func2里面的逻辑可以但是也相当麻烦。 但是如果使用递归锁的话，就可以解决这个问题了。另外一个情形相对比较简单，就是如果信号处理 函数里面也使用同一个锁的话。

###可重入与线程安全

可重入这个话题在信号处理已经讨论过了，可重入函数一定是线程安全函数，但是线程安全不一定是可重入的。如果 一个函数可在同一时刻被多个线程安全调用的话，那么这个函数就是线程安全的。对于一些线程不安全函数的，如果 操作系统需要支持线程安全性的话，那么会定义POSIXTHREADSAFEFUNCTIONS/SCTHREADSAFEFUNCTIONS，同时对于 一些线程不安全函数，提供一个线程安全的版本，通常以r结尾。

标准IO提供了函数来保证操作标准IO是线程安全的：

	int ftrylockfile(FILE* fp);
	void flockfile(FILE* fp);
	void funlockfile(FILE* fp);

但是实际上我们操作标准IO而言的话是不需要使用这些函数的，因为标准IO内部保证线程安全的。如果我们进行信号处理 多次fprintf的话不会hang住，所以内部实现应该是递归锁，在同一个线程内多次调用没有任何问题。标准IO默认提供递归锁 又引入了一个问题，那就是如果我们操作字符的时候，如果每次操作字符都要加锁那么代价是非常大的，所以标准IO还提供了另外 一个接口是允许不加锁的操作字符

	#include <cstdio>
	int getchar_unlocked();
	int getc_unlocked(FILE* fp);
	int putchar_unlocked();
	int putc_unlocked(FILE* fp);

###线程私有数据

引入线程之后，我们就有必须重新考虑变量作用域的问题。在引入线程之前，我们有全局变量和局部变量。但是在多个线程情况下， 如果我们将线程当做一个单独实体的话，那么多出了一个作用域，就是相对于线程来说的全局变量。这种变量我们称为线程 私有数据。每个线程私有数据对应一个键，通过这个键来获取对线程私有数据的访问权。考虑如果没有这个线程私有数据的话， 那么我们线程里面每个函数都必须将这个对象作为参数传入，何其繁琐。

	int pthread_key_create(pthread_key_t* keyp,void (*destructor)(void*));
	int pthread_key_delete(pthread_key_t* key);
	void* pthread_getspecific(pthread_key_t key);
	int pthread_setspecific(pthread_key_t key,const void* value);

创建的键存放在keyp指向的内存单元，这个键可以被所有线程使用，但是不同线程将这个键关联到不同的线程私有数据上。 每个创建的键都设置了一个析构函数，如果为NULL的话那么析构函数不调用。当线程调用pthreadexit或者是线程执行返回的时候， 析构函数才会调用。keydelete只是释放key这个内存，并不会调用析构函数。

线程对于创建的键的数量是存在限制的，可以通过PTHREADKEYSMAX来获得。线程退出时会尝试调用一次析构函数，如果所有键 绑定的值都已经释放为null的话，那么正常，否则还会尝试调用一次析构函数，直到尝试次数为PTHREADDESTRUCTORITERATIONS次数。

###取消选项

线程分为是否可以取消，以及如果允许取消的话是延迟还是异步取消。设置线程取消可以通过：

	//1.PTHREAD_CANCEL_ENABLE
	//2.PTHREAD_CANCEL_DISABLE
	int pthread_setcancelstate(int state,int* oldstate);

默认启动的时候线程是可以取消的。如果线程是不可以取消的话那么pthreadcancel不会杀死线程，只是进行标记。 直到线程变成ENABLE状态之后，在下一个取消点才会进行取消。

这里有一个术语就是取消点，取消点是线程检查是否被取消并且按照请求进行动作的一个位置。我们没有必要记住 所有的取消点，因为pthread本身就提供了一个取消点pthreadtestcancel.如果线程允许取消的话，调用这个函数 会判断是否存在取消标记，如果有取消标记的话，那么就会停止线程。

取消时机也分延迟取消还是异步取消，延迟取消就是我们所看到的到达某个同步点才取消，而异步取消的话线程可以在 任意时间取消，而不是遇到取消点才取消。设置取消时机的接口是

	//1.PTHREAD_CANCEL_DEFERRED
	//2.PTHREAD_CANCEL_ASYNCHRONOUS
	int pthread_setcanceltype(int type,int* oldtype);

###线程和信号

每个线程有自己的信号屏蔽字，但是信号的处理是所有线程共享的。进程中的单个信号是递送到单个线程的，如果信号 与硬件故障或者是计时器相关的话，那么信号就会发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程中。 POSIX.1的线程模型中，异步信号被发送到进程以后，进程中当前没有阻塞该信号的某个线程来处理该信号。

每个线程有自己的信号屏蔽字，如果我们使用sigprocmask的话对于多线程是没有定义的。为此pthread提供了pthreadsigmask 来为每个线程提供线程的信号屏蔽字。此外线程还可以通过调用sigwait来等待一个或者是多个信号发生。语义和sigsuspend一样， 但是可以获得等待到的信号编号。sigwait会首先清除未决的信号，然后打开需要截获的信号，这也意味这在sigwait之前需要屏蔽 需要关心的信号，然后调用sigwait.

	#include <signal.h>
	int pthread_sigmask(int how,const sigset_t* restrict set,sigset_t* restrict oset);
	int sigwait(const sigset_t* restrict set,int* restrict signop);

使用sigwait可以简化信号处理，允许把异步的信号用同步的方式处理。我们可以将正常线程屏蔽信号，然后只让某一个线程处理信号。 这样能够按照同步方式来处理信号，非常方便。

	#include <unistd.h>
	#include <signal.h>
	#include <pthread.h>
	#include <cstdio>
	#include <cstdlib>
	#include <cstring>
	int quit_flag=0;
	//此线程专门处理信号
	void* signal_handler_thread(void* arg){
	    sigset_t set;
	    sigfillset(&set);
	    pthread_sigmask(SIG_BLOCK,&set,NULL);
	    sigemptyset(&set);
	    sigaddset(&set,SIGINT);
	    sigaddset(&set,SIGUSR1);
	    sigaddset(&set,SIGUSR2);
	    for(;;){
	        int signo;
	        sigwait(&set,&signo);
	        //in a synchronous way.
	        printf("%s received\n",strsignal(signo));
	        if(signo==SIGINT){
	            quit_flag=1;
	            return NULL;
	        }
	    }
	}
	//main主线程非常轻松，屏蔽了所有的信号，
	//而在专门的线程里面以一种同步的方式来处理信号
	int main(){
	    sigset_t set;
	    sigfillset(&set);
	    pthread_sigmask(SIG_BLOCK,&set,NULL);
	    pthread_t tid;   
	    pthread_create(&tid,NULL,signal_handler_thread,NULL);
	    for(;;){
	        sleep(1);
	        if(quit_flag==1){
	            pthread_join(tid,NULL);
	            return 0;
	        }
	    }
	    return 0;
	}

进程之间发送信号也是可以的。我们也可以传递信号0来判断线程是否存在。

	#include <signal.h>
	int pthread_kill(pthread_t thread,int signo);

注意闹钟定时器是进程资源，并且所有的线程共享相同的alarm.所以进程中的多个线程不可能互不干扰地使用闹钟定时器。

###线程和fork

个人觉得相当无用而且异常繁琐。为了保证锁和条件变量的状态，使用到了pthreadatfork.

###线程和IO

多线程IO下面读写文件的话，底层能够保证一次read/write的串行化，可以认为是一个原子操作。 但是需要考虑的是，线程需要lseek来定位的话，那么这就是一个非原子操作。因为在lseek和read/write之间的话， 位置可能已经发生了变化。我们可以通过系统调用pread/pwrite来满足我们的需求，这是两个原子操作。