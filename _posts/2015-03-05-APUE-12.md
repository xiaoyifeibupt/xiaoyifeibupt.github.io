---
layout: post
title:  APUE——守护进程
categories: [APUE]
---



守护进程也是精灵进程(daemon),是一种生存期较长的进程，常常在系统自举时候启动，仅仅在系统关闭时终止。 因为没有控制终端所有在后台运行。常见的守护进程有下面这些：

-	init.系统守护进程，负责启动各个运行层次的特定系统服务。
-	keventd.为内核中运行计划执行的函数提供进程上下文。
-	kampd.对高级电源管理提供支持。
-	kswapd.页面调度守护进程。
-	bdflush.当可用内存到达某个下限的时候，将脏缓冲区从缓冲池(buffer cache)冲洗到磁盘上。
-	kupdated.将脏页面冲洗到磁盘上，以便在系统失效时减少丢失的数据。
-	portmap.将rpc程序号映射为网络端口号。
-	syslogd.系统消息日志服务器。
-	xinted.inted守护进程。
-	nfsd,lockd,rpciod.支持NFS的一组守护进程。
-	crond.在指定的日期和时间执行特定的命令。
-	cupds.打印假脱机进程，处理对系统提出的所有打印请求。

###daemonize

产生一个daemon程序需要一系列的操作，步骤如下：

1. umask(0).因为我们从shell创建的话，那么继承了shell的umask.这样导致守护进程创建文件会屏蔽某些权限。
2. fork然后使得父进程退出。一方面shell认为父进程执行完毕，另外一方面子进程获得新的pid肯定不为进程组组长，这是setsid前提。
3. setsid来创建新的会话。这时候进程称为会话首进程，称为第一个进程组组长进程同时失去了控制终端。
4. 最好在这里再次fork。这样子进程不是会话首进程，那么永远没有机会获得控制终端。如果这里不fork的话那么会话首进程依然可能打开控制终端。
5. 将当前工作目录更改为根目录。父进程继承过来的当前目录可能mount在一个文件系统上。如果不切换到根目录，那么这个文件系统不允许unmount.
6. 关闭不需要的文件描述符。可以通过SCOPENMAX来判断最高文件描述符(不是很必须).
7. 然后打开/dev/null复制到0,1,2(不是很必须).


	void print_ids(const char* name){
	    printf("%s:pid=%d,ppid=%d,pgid=%d,sid=%d\n",
	           name,getpid(),getppid(),getpgid(0),getsid(0));
	    //printf("%s\n",name);
	}
	
	void daemonize(){    
	    umask(0);
	    pid_t pid=fork();
	    if(pid!=0){
	        exit(0);
	    }
	    sleep(1);
	    print_ids("after fork()");
	    setsid();
	    print_ids("after setsid()");
	    pid=fork();
	    if(pid!=0){
	        exit(0);
	    }    
	    print_ids("after fork()");
	    chdir("/");
	    long v=sysconf(_SC_OPEN_MAX);
	    for(long i=0;i<v;i++){
	        close(i);
	    }        
	    open("/dev/null",O_RDWR);
	    dup(0);
	    dup(0);
	}

实验之后发现其实控制终端依然还是存在的并且依然可写(不过在关闭之后定位到/dev/null不可写了)。但是如果本次链接断开之后下次重新链接的话， 那么就会失去这个控制终端。其实似乎建立一个这样的东西完全没有必要这么麻烦，甚至最后面setsid和第二次fork都不需要，因为第一个子进程 已经成为一孤儿进程组，shell会话是不会影响到它的。

	void daemonize(){    
	    umask(0);
	    pid_t pid=fork();
	    if(pid!=0){
	        exit(0);
	    }
	    chdir("/");
	    long v=sysconf(_SC_OPEN_MAX);
	    for(long i=0;i<v;i++){
	        close(i);
	    }        
	    open("/dev/null",O_RDWR);
	    dup(0);
	    dup(0);
	}

###出错处理

我们假设daemon不会将错误信息输出到终端上。如果我们只是写到一个单独的文件，那么非常难以管理。所以有必要有 一个集中设施来管理出错记录。BSD的syslog就是这个集中设施。设施大体分布是这样的：

-	syslogd守护进程专门接受记录，然后决定写文件，本地或者发送到远程主机。配置文件是/etc/syslog.conf

-	用户进程通过syslog传递到syslogd,通信机制是unix domain socket,文件是/dev/log.
-	TCP/IP可以通过访问UDP 514端口和syslogd通信提交日志。
-	内核例程通过log函数传递到syslogd,通信机制也是unix domain socket,文件是/dev/klog.

syslog的设施接口是下面这样的：

	#include <syslog.h>
	//facility通常为LOG_USER
	void openlog(const char* ident,int option,int facility);
	void syslog(int priority,const char* format,...); //priority是facility和level的组合
	void closelog();
	int setlogmask(int maskpri); //屏蔽的priority

如果我们直接使用syslog也是可以，但是这样会损失很多功能，所以还是很推荐使用openlog首先打开，然后再syslog这种方式。

	option	说明
	LOGCONS	如果不能够通过unix domain socket传递到syslogd,那么直接输出到控制台
	LOGNDELAY	立即打开至syslogd的unix domain socket.通常来说默认是syslog第一条记录之后再建立连接
	LOGODELAY	不立即打开至syslogd的uds
	LOGPERROR	日志消息不仅仅发送给syslog,同时写到标准错误上
	LOGPID	每个消息都包含pid
	level	说明
	LOGEMERG	紧急状态(系统不可使用),最高优先级
	LOGALERT	必须立即修复的状态
	LOGCRIT	严重状态
	LOGERR	出错状态
	LOGWARNING	警告状态
	LOGNOTICE	正常状态
	LOGINFO	信息性消息
	LOGDEBUG	调试消息

看完这个之后我们看看一份syslog.conf的样例配置

	# Log all kernel messages to the console.
	# Logging much else clutters up the screen.
	#kern.*                                                 /dev/console
	kern.*                                                  /var/log/kernel
	# Log anything (except mail) of level info or higher.
	# Don't log private authentication messages!
	*.info;mail.none;authpriv.none;cron.none                /var/log/messages
	
	# The authpriv file has restricted access.
	authpriv.*                                              /var/log/secure
	
	# Log all the mail messages in one place.
	mail.*                                                  -/var/log/maillog
	
	
	# Log cron stuff
	cron.*                                                  /var/log/cron
	
	# Everybody gets emergency messages
	*.emerg                                                 *
	
	# Save news errors of level crit and higher in a special file.
	uucp,news.crit                                          /var/log/spooler
	
	# Save boot messages also to boot.log
	local7.*                                                /var/log/boot.log
	*.*             @fwefcerq

可以看到每个项分两个部分，第一个是priority,第二个就是写的位置。如果*那么都会收到这个message.

	#include <syslog.h>
	int main(){
	    openlog("FuckYourAss",0,LOG_EMERG);
	    syslog(0,"%s\n","Fuck Your Ass!!!!");
	    closelog();
	}

###其他事项

守护进程通常单实例运行的，为了保证是单例运行的话，我们可以通过文件标记或者是文件锁来完成。 在Unix下面守护进程通常有下面这些惯例：

-	守护进程的锁文件，通常存放在/var/run/<name>.pid
-	如果守护进程有配置文件的话，那么文件存放在/etc/<name>.conf
-	守护进程可以使用命令行启动，但是通常是在系统初始化脚本之一存放在/etc/init.d/*下面。
-	守护进程终止的话我们通常希望重启。而守护进程的父进程通常为init.在/etc/inittab里面为守护进程包含respawn选项的话，那么守护进程终止的话init会自动重启。
-	因为守护进程和终端不连接，所以永远接收不到SIGHUP信号。我们可以使用SIGHUP信号来通知守护进程重新载入配置文件。守护进程必须支持这个功能。