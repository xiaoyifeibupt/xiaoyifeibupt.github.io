---
layout: post
title:  APUE——高级I/O
categories: [APUE]
---




###非阻塞IO

首先必须明确为什么需要引入非阻塞IO这个概念。因为系统调用存在低速系统调用，可能使进程永久阻塞住。 通常包括下面这些进程：

-	某些文件类型比如管道，终端设备和网络设备数据并不存在。
-	数据不能够被文件立即接受，比如管道无空间或者是网络流控制等。
-	打开某些类型文件比如调制解调器等等待应答。
-	对于文件加上了强制锁进行的读写。
-	某些ioctl操作。
-	某些进程间通信函数。

但是我们必须区分磁盘IO相关的系统调用，这些并不是低速系统调用。对于非阻塞IO操作的话，如果没有成功的话， 那么不会阻塞而是立即返回一个错误表示EAGAIN.

对于一个给定的描述符设置非阻塞IO属性的话，要不可以通过在open时候指定，要不通过fcntl来修改为ONONBLOCK状态。

###记录锁

建议锁和强制锁之间的差别，建议锁更强调协作方面的特性只是一个软规定，而对于强制锁来说， 如果我们加上强制锁的话那么以阻塞方式来读写的话那么就一定会阻塞，是一个硬性规定。强制锁和建议锁底层都是记录锁。


记录锁(record locking)的功能是当一个进程正在读或者是修改文件的某一个部分的话，它可以阻塞其他进程修改 同一个文件区域。对于文件区域来说，是一个范围，可以锁几个字节也可以尝试锁一个文件。记录锁有下面这些属性：

-	进程终止时，进程建立的锁全部释放。
-	关闭任何一个描述符时，那么这个描述符可以引用的任何所都会被释放。
-	fork出来的子进程继承文件描述符但是却不继承记录锁。
-	exec之后会继承文件描述符和锁。但是如果文件标识设置了close-on-exec的话，那么会自动关闭。

这里可以看到，记录锁是和文件描述符以及进程相关联的。在具体实现可以看到为什么是这样的。

####接口
我们使用fcntl来操纵记录锁，那么接口是

	#include <fcntl.h>
	struct flock
	  {
	    short int l_type;   /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
	    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */
	#ifndef __USE_FILE_OFFSET64
	    __off_t l_start;    /* Offset where the lock begins.  */
	    __off_t l_len;      /* Size of the locked area; zero means until EOF.  */
	#else
	    __off64_t l_start;  /* Offset where the lock begins.  */
	    __off64_t l_len;    /* Size of the locked area; zero means until EOF.  */
	#endif
	    __pid_t l_pid;      /* Process holding the lock.  */
	  };
	//cmd可以是F_GETLK,F_SETLK(non-wait),F_SETLKW(wait)
	int fcntl(int fd,int cmd,struct flock* lockp);

可以看到锁的类型还区分为读写锁，加锁操作分为了阻塞和非阻塞两个版本。如果从字节范围上来看的话， 那么1个锁可能会拆分成为多个锁得可能。假设一开始我们锁住范围[a,b],然后中途释放了[c,d]，那么之后 我们有把锁，分别是[a,c],[d,b].

在这里我们有一个问题需要注意，如果llen设置为0的话，锁住的大小始终是文件的最末端。如果文件不断 追加写的话，那么记录锁的范围是越来越大的。这样在释放的时候，也要释放对应的范围。

####实现

实现上来说，所有的锁都是挂在在v节点表之后的，以链表形式挂接：

	struct lockf{
	    struct lockf* next;
	    flag_t flag; //标识
	    off_t start; //起始偏移量
	    off_t len; //长度
	    pid_t pid; //是什么进程尝试锁住文件的
	};

对于锁来说里面保存了是什么进程锁住文件的，所以子进程并不能够继承父进程的锁而exec可以。

###IO多路转接

如果我们希望可以监视多个IO操作的话，那么会遇到一个问题。对于阻塞IO的话，我们必须安排一定的顺序来读取， 对于非阻塞IO的话我们必须耗费大量时间在轮询上。另外一种方式就是使用异步信号IO,但是它通常只是告诉我们 有文件描述符准备好了但是在信号处理部分我们还是要轮询一次。IO多路转接(IO multiplexing)就是用来解决这个问题的， 效果相当于构造一个文件描述符表，然后如果可读可写或者是发生异常的话就会返回一个准备好的fd集合。

####select/pselect

	#include <sys/select.h>
	/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
	   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
	   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
	   after waiting the interval specified therein.  Returns the number of ready
	   descriptors, or -1 for errors.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern int select (int __nfds, fd_set *__restrict __readfds,
	                   fd_set *__restrict __writefds,
	                   fd_set *__restrict __exceptfds,
	                   struct timeval *__restrict __timeout);
	
	#ifdef __USE_XOPEN2K
	/* Same as above only that the TIMEOUT value is given with higher
	   resolution and a sigmask which is been set temporarily.  This version
	   should be used.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern int pselect (int __nfds, fd_set *__restrict __readfds,
	                    fd_set *__restrict __writefds,
	                    fd_set *__restrict __exceptfds,
	                    const struct timespec *__restrict __timeout,
	                    const __sigset_t *__restrict __sigmask);
	#endif

pselect相对于改进的话是首先时间信息使用timespect支持到纳秒级别，更加精确。同时时间不会发生修改。 此外还提供了信号屏蔽字。其中nfds表示后面几个fdset里面最大的文件描述符+1.相当于我们告诉select/pselect:

-	我们关心的描述符有哪些。
-	关心描述符状态，比如是可读可写还是出现异常状态。
-	愿意等待多长时间可以永远等待或者是等待一个固定时间，或者是立即返回。

而系统返回：

-	已准备好的文件描述符数量
-	哪些文件描述符准备好了。

如果返回-1的话，表示出错那么fds里面内容不变。如果返回0的话表示没有准备好的fd。我们不应该假设 fds不会修改，所以最好每次都重新进行设置。对于timeout的话，如果提前返回的话，那么里面存放的是剩余时间。

这里我们看到有一个fd集合，原则上和sigsett接口是一样的，但是更简单一些：

	#define __FD_SETSIZE            1024
	/* fd_set for select and pselect.  */
	typedef struct
	  {
	    /* XPG4.2 requires this member name.  Otherwise avoid the name
	       from the global namespace.  */
	#ifdef __USE_XOPEN
	    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
	# define __FDS_BITS(set) ((set)->fds_bits)
	#else
	    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
	# define __FDS_BITS(set) ((set)->__fds_bits)
	#endif
	  } fd_set;
	
	/* Access macros for `fd_set'.  */
	#define FD_SET(fd, fdsetp)      __FD_SET (fd, fdsetp)
	#define FD_CLR(fd, fdsetp)      __FD_CLR (fd, fdsetp)
	#define FD_ISSET(fd, fdsetp)    __FD_ISSET (fd, fdsetp)
	#define FD_ZERO(fdsetp)         __FD_ZERO (fdsetp)

可以看到对于一个fdset最多允许1024个文件描述符进行监听。

这里准备好的情况是这样定义的：

-	对于读来说的话那么read操作将不会阻塞。
-	对于写来说的话那么write操作将不会阻塞。
-	对于异常状态集得话描述符中有一个未决的异常状态比如存在带外数据。

文件描述符本身的阻塞与否不会影响到select/pselect的行为的，select/pselect给出的界面还是阻塞行为的。

####poll/ppoll

	#include <poll.h>
	/* Type used for the number of file descriptors.  */
	typedef unsigned long int nfds_t;
	
	/* Data structure describing a polling request.  */
	struct pollfd
	  {
	    int fd;                     /* File descriptor to poll.  */
	    short int events;           /* Types of events poller cares about.  */
	    short int revents;          /* Types of events that actually occurred.  */
	  };
	
	/* Poll the file descriptors described by the NFDS structures starting at
	   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
	   an event to occur; if TIMEOUT is -1, block until an event occurs.
	   Returns the number of file descriptors with events, zero if timed out,
	   or -1 for errors.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);
	
	#ifdef __USE_GNU
	/* Like poll, but before waiting the threads signal mask is replaced
	   with that specified in the fourth parameter.  For better usability,
	   the timeout value is specified using a TIMESPEC object.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
	                  __const struct timespec *__timeout,
	                  __const __sigset_t *__ss);

和select/pselect一样，pool提供了接口。其中nfds表示fds数组数量。timeout在这里单位是微秒。 和select/pselect最大的不同是，返回之后并不会修改fds里面fd和events字段内容，产生的事件 直接写在revent字段里面。我们可以看看poll支持的事件有哪些：

	标识名	events	revents	说明
	POLLIN	y	y	可以不阻塞地读取出高优先级之外的数据(等效于PLLRDNORM & POLLRDBAND)
	POLLRDNORM	y	y	不阻塞地读取普通数据(优先级为0波段数据)
	POLLRDBAND	y	y	不阻塞地读取非0优先级波段数据
	POLLPRI	y	y	不阻塞地读取高优先级数据
	POLLOUT	y	y	不阻塞地写普通数据
	POLLWRNORM	y	y	和POLLOUT相同
	POLLWRBAND	y	y	不阻塞地写非0优先级波段数据
	POLLERR		y	已经出错
	POLLHUP		y	已经挂断
	POLLNVAL		y	描述符无效


####自动重启
上面4个都属于系统调用，取决于安装的系统是否默认为信号自动重启。不过在编写应用程序时候最好不要假设这点， 相反应该假设系统调用不会自动重启，所以我们必须检测出错并且errno==EINTR的可能。

###异步IO

异步IO是通过信号同时来实现的，并且异步IO对应的只有有限的几个信号。这样在信号处理函数中我们还必须仔细 判断哪些文件描述符是可读，可写或者是异常的。对于BSD派生出来的系统，使用的信号是SIGIO和SIGURG(猜想linux和bsd应该走得很近). SIGIO是通用异步信号，而SIGURG是用药通知进程在网络连接上有带外数据。为了使用SIGIO的话，需要执行下面三个步骤：

-	调用signal为SIGIO建立处理函数
-	使用FSETOWN为fd设置进程和进程组。因为一旦fd触发信号的话，系统是要决定信号投递到哪个进程和进程组的。
-	使用FSETFL来设置OASYNC文件状态标志。对于BSD来说仅仅用于终端或者是网络的描述符。

对于SIGURG只需要设置前面两个步骤，信号仅仅是用于支持带外数据的网络连接描述符产生的。

	#include <unistd.h>
	#include <fcntl.h>
	#include <pthread.h>
	#include <signal.h>
	#include <cstdio>
	#include <cstring>
	
	static int id=0;
	void sig_handler(int signo){
	    printf("%s received(%d)\n",strsignal(signo),id);
	    id++;
	}
	
	int main(){
	    signal(SIGIO,sig_handler);
	    fcntl(0,F_SETOWN,getpid());    
	    fcntl(0,F_SETFL,fcntl(0,F_GETFL) | O_ASYNC);
	    pause();
	    return 0;
	}
	//发送多次SIGIO信号之后才被pause所捕获到
	[dirlt@localhost.localdomain]$ ./a.out 
	1I/O possible received(0)
	I/O possible received(1)
	I/O possible received(2)
	I/O possible received(3)
	I/O possible received(4)
	I/O possible received(5)
	I/O possible received(6)
	I/O possible received(7)
	I/O possible received(8)
	I/O possible received(9)
	I/O possible received(10)
	I/O possible received(11)
	I/O possible received(12)
	I/O possible received(13)
	I/O possible received(14)

###readv/writev

readv和writev能够将分散的多块缓冲区一次性读出和写入，而仅仅是是用一次系统调用

	#include <sys/uio.h>
	
	/* Structure for scatter/gather I/O.  */
	struct iovec
	  {
	    void *iov_base;     /* Pointer to data.  */
	    size_t iov_len;     /* Length of data.  */
	  };
	/* Read data from file descriptor FD, and put the result in the
	   buffers described by IOVEC, which is a vector of COUNT `struct iovec's.
	   The buffers are filled in the order specified.
	   Operates just like `read' (see <unistd.h>) except that data are
	   put in IOVEC instead of a contiguous buffer.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern ssize_t readv (int __fd, __const struct iovec *__iovec, int __count);
	
	/* Write data pointed by the buffers described by IOVEC, which
	   is a vector of COUNT `struct iovec's, to file descriptor FD.
	   The data is written in the order specified.
	   Operates just like `write' (see <unistd.h>) except that the data
	   are taken from IOVEC instead of a contiguous buffer.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern ssize_t writev (int __fd, __const struct iovec *__iovec, int __count);

读取的话是首先填满第一个缓冲区，然后填写第二个缓冲区。写入的话也是按照iovec的顺序来写入的。

###存储映射IO

存储映射IO(memoryy-mapped IO)使得一个磁盘文件于存储空间中的一个缓冲区相映射。这样读取缓冲区的内容就 相当读取磁盘文件的内容，同样如果写缓冲区的话就直接修改文件。映射区域和具体实现相关，但是通常映射在 堆栈之间的存储区域内部。

	#include <sys/mman.h>
	/* Map addresses starting near ADDR and extending for LEN bytes.  from
	   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR
	   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is
	   set in FLAGS, the mapping will be at ADDR exactly (which must be
	   page-aligned); otherwise the system chooses a convenient nearby address.
	   The return value is the actual mapping address chosen or MAP_FAILED
	   for errors (in which case `errno' is set).  A successful `mmap' call
	   deallocates any previous mapping for the affected region.  */
	extern void *mmap (void *__addr, size_t __len, int __prot,
	                   int __flags, int __fd, __off_t __offset) __THROW;
	
	/* Deallocate any mapping for the region starting at ADDR and extending LEN
	   bytes.  Returns 0 if successful, -1 for errors (and sets errno).  */
	extern int munmap (void *__addr, size_t __len) __THROW;
	
	/* Change the memory protection of the region starting at ADDR and
	   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors
	   (and sets errno).  */
	extern int mprotect (void *__addr, size_t __len, int __prot) __THROW;
	
	/* Synchronize the region starting at ADDR and extending LEN bytes with the
	   file it maps.  Filesystem operations on a file being mapped are
	   unpredictable before this is done.  Flags are from the MS_* set.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern int msync (void *__addr, size_t __len, int __flags);

对于mmap来说：

-	addr表示我们希望映射到什么地址上，这只是一个建议通常设置为0即可。
-	fd就是文件描述符，offset表示偏移位置，len表示开辟的内存空间大小。

对于prot(protection)有下面这几个值：

	prot	说明
	PROTREAD	映射区可读
	PROTWRITE	映射区可写
	PROTEXEC	映射区可执行
	PROTNONE	映射区不可以访问 
对于flag有下面资格几个值：

	flag	说明
	MAPFIXED	说明地址必须为addr,这样容易造成不可一致性一般不使用
	MAPSHARED	标记如果修改的话那么修改对应磁盘文件
	MAPPRIVATE	标记如果修改的话那么只是修改本地的副本，而不会修改到磁盘文件 

通常来说mmap分配出的内存和大小是按照SCPAGESIZE来对齐的。与mmap相关的两个信号是这样的SIGSEGV 和SIGBUS.如果我们映射文件为1K,SCPAGESIZE=4K的话，那么我们访问对应1K没有任何问题， 如果访问1K以外4K以内，因为内存分配出来了所以访问没有问题，但是没有对应文件那么返回SIGBUS. 如果访问4K以外的话，因为没有分配内存那么返回SIGSEGV.

	#include <unistd.h>
	#include <fcntl.h>
	#include <sys/stat.h>
	#include <sys/mman.h>
	#include <cstdio>
	#include <cstring>
	#include <cstdlib>
	#include <signal.h>
	
	void signal_handler(int signo){
	    printf("%s received\n",strsignal(signo));
	    exit(0);
	}
	
	int main(){
	    signal(SIGSEGV,signal_handler);
	    signal(SIGBUS,signal_handler);
	    struct stat stat_buf;
	    stat("main.cc",&stat_buf);
	    int fd=open("main.cc",O_RDWR);    
	    char* addr=(char*)mmap(NULL,stat_buf.st_size,PROT_READ | PROT_WRITE,MAP_SHARED,fd,0);
	    close(fd);
	    getchar(); //这个地方将main.cc删除掉
	    printf("change last one byte\n");
	    addr[stat_buf.st_size-1]='x';
	    msync(addr,stat_buf.st_size,MS_SYNC); //最后还尝试进行同步
	    munmap(addr,stat_buf.st_size);
	    return 0;
	}

我们这里并没有复现SIGBUS这个错误，而且尝试了很多情况也没有SIGBUS这个问题。我在想如果已经分配出来的话， 那么在上面操作都是允许的。如果底层没有文件对应的话，那么写就没有任何效果。

mprotect可以修改内存的访问权限，prot字段和mmap的prot字段含义对应。msync的flags有下面这几个：

-	MSSYNC将页面冲洗到被映射的文件同步返回。
-	MSASYNC将页面冲洗到被映射的文件中异步返回。
-	MSINVALIDATE通知操作系统丢弃与底层存储器没有永不的任何页。

munmap不会使得映射区的内容写到磁盘文件上，MAPSHARED磁盘文件的更新是通过系统自带的虚存算法来进行自动更新的， 而对于MAPPRIVATE的存储区域就直接丢弃。