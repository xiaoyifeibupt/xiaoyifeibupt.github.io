---
layout: post
title:  APUE——进程间通信
categories: [APUE]
---


unix系统下面的IPC(inteprocess communication)主要分为下面这几种：

-	pipe
-	fifo
-	消息队列
-	信号量
-	共享存储
-	uds(unix domain socket)
-	套接字

其中套接字可以跨机器进程通信，而之前几类都是单机进程之间通信。套接字有专门一节用于说明， 这节仅仅说前面几类单机进程通信手段。unix domain socket也属于套接字范围，所以在这里没有单独叙述。

###pipe

管道是最古老的unix ipc，几乎所有的unix系统上都会提供这种通信机制。但是管道有两种局限性：

-	半双工。
-	必须具备进程关系，比如父子进程。

fifo没有第二种局限性，而uds两种局限性都没有。产生管道非常简单

	#include <unistd.h>
	int pipe(int fd[2]);

这样fd(0)可用用来读，fd(1)可以用来写。对于理解管道的话，我们最好理解为fd(0)和fd(1)之间还有一个 管道缓冲区。因为管道有这样的行为，如果多个同时写的话，如果一次写的字节数小于PIPEBUF的话，那么 可以保证之间是没有穿插行为的，

本质上pipe可以认为是一个匿名的fifo,而实际的fifo则是一个命名的fifo.所以如果使用fstat来测试的话， SISFIFO是成功的。和套接字一样，如果写端关闭的话那么读端读取返回0，如果读端关闭的话那么写端会产生SIGPIPE信号错误， 返回错误为EPIPE.

	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <unistd.h>
	#include <cstring>
	#include <cstdlib>
	#include <cstdio>
	
	int main(){
	    int fd[2];
	    pipe(fd);
	    struct stat stat_buf;
	    fstat(fd[0],&stat_buf);
	    printf("PIPE_BUF=%d,S_ISFIFO=%d\n",
	           fpathconf(fd[0],_PC_PIPE_BUF),
	           S_ISFIFO(stat_buf.st_mode));
	    pid_t pid=fork();
	    if(pid==0){//child
	        close(fd[1]);
	        char buf[1024];
	        read(fd[0],buf,sizeof(buf));
	        printf("%s\n",buf);
	        exit(0);
	    }
	    close(fd[0]);
	    write(fd[1],"hello,world",strlen("hello,world")+1);
	    wait(NULL);
	    return 0;
	}
	[dirlt@localhost.localdomain]$ ./a.out 
	PIPE_BUF=4096,S_ISFIFO=1
	hello,world

管道pipe还有另外两个比较有用的函数分别是

	#include <cstdio>
	FILE* popen(const char* cmd,const char* type);
	int pclose(FILE* fp);

API看上去和打开文件一样，只不过打开的是一个执行命令。对于type来说只允许是"r"或者是"w". pclose返回的结果和system一样，可能会返回执行命令的内容，如果shell不成功返回127,如果接收到信号退出的话， 那么返回128+信号编号。实现上我们值得思考一下，就是popen通常来说肯定是创建了一个进程，然后FILE里面记录的 fd必然和这个进程号做了一个绑定。不然我们在pclose使用FILE*必须能够找到，我们应该wait什么进程终止。 在pclose必须fclose掉句柄，不然如果作为一输入命令的话那么会一直等待输入完成。

	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <unistd.h>
	#include <cstring>
	#include <cstdlib>
	#include <cstdio>
	
	int main(){
	    FILE* fp=popen("cat > tmp.txt","w");
	    fputs("hello,world\n",fp);
	    int status=pclose(fp);
	    printf("status:%d\n",status);
	    return 0;
	}

###fifo

这里的fifo是指命名fifo.和管道特征一样，一次字节小于PIPEBUF保证不会穿插，并且没有写端读端返回0,没有读端 写端产生SIGPIPE并且返回EPIPE错误，测试类型为SISFIFO.命名fifo依赖于特殊文件，然后通过读写文件来进行数据传递。

	#include <sys/stat.h>
	int mkfifo(const char* pathname,mode_t mode);

如果我们只读打开的话，那么会等待直到某个进程为写打开fifo.如果设置ONONBLOCK打开的话，那么会立刻返回没有错误。 如果我们只写打开的话，那么会等待直到某个进程为读打开fifo.如果设置ONNOBLOCK打开的话，那么会立刻返回错误ENXIO.

	int main(){
	    mkfifo("./fifo",0666);
	    pid_t pid=fork();
	    if(pid==0){
	        int fd=open("./fifo",O_RDONLY);
	        char buf[1024];
	        read(fd,buf,sizeof(buf));
	        printf("%s\n",buf);
	        close(fd);
	        exit(0);
	    }
	    int fd=open("./fifo",O_WRONLY);
	    write(fd,"hello,world",strlen("hello,world")+1);
	    close(fd);
	    wait(NULL);
	    unlink("./fifo");
	    return 0;
	}

###XSI IPC

XSI IPC包括的就是消息队列，信号量和共享存储，他们有很多相似之处，所以在开头我们介绍相似之处的功能。 首先需要说明的是IPC相当于重复了一次文件的语义，并且在底层实现上可能就是通过文件来完成的。在学习IPC 的时候，尽可能地对比和文件的接口。

####创建标识

和文件的文件描述符类似，IPC也是通过一个非负整数来表示一个IPC资源的，然后之后的操作都是针对这个id来引用 ipc资源的。但是必须注意的是，这个非负整数并不一定很小，虽然获得这个整数也是通过+1来得到的，但是注意 IPC资源是全局的，所以在得到这个整数之前可能尝试获取多次了IPC资源。

和文件的open对象，我们需要打开某个东西才能够获得这个IPC标识。在文件下面是文件路径，在IPC下面是keyt, 在<sys/types.h>里面定义，可以认为是一个整数。从keyt到IPC标识这个过程内核来完成，接口如下：

	int xxxget(key_t key,int flag); /返回IPC标识

这个keyt如何指定有几种方法：

keyt指定为IPCPRIVATE的话，那么每次都会创建一个新IPC标识。

通过ftok函数来生成一个keyt
	#include <sys/ipc.h>
	key_t ftok(const char* path,int id); //id在[0,255]

ftok必须引用一个已经存在的路径。底层实现可能是得到path的stdev和stino两个字段，然后配合id来生成keyt.但是也可能会出现重复。 对于IPCPRIVATE来说每次都会创建，而对于ftok来说的话，flag有IPCCREATE | IPCEXCL两个参数，和open类似，来获取当前IPC标识或者是创建。 同时还需要注意的是，flag的低9位是表示权限的，如果我们要允许读写的话那么必须指定0666.

####权限结构

对于每一个IPC结构都设置了ipcperm结构，规定了权限和所有者。

	#include <sys/ipc.h>
	/* Data structure used to pass permission information to IPC operations.  */
	struct ipc_perm
	  {
	    __key_t __key;                      /* Key.  */
	    __uid_t uid;                        /* Owner's user ID.  */
	    __gid_t gid;                        /* Owner's group ID.  */
	    __uid_t cuid;                       /* Creator's user ID.  */
	    __gid_t cgid;                       /* Creator's group ID.  */
	    unsigned short int mode;            /* Read/write permission.  */
	    unsigned short int __pad1;
	    unsigned short int __seq;           /* Sequence number.  */
	    unsigned short int __pad2;
	    unsigned long int __unused1;
	    unsigned long int __unused2;
	  };

对于uid和gid都是有效的uid和gid.通常来说我们只需要uid和gid,但是因为系统没有内置保存设置uid和gid,所以在权限结构 里面显示存在这样的cuid和cgid字段。通常我们可以修改的就是uid,gid以及mode,和chown/chmod对应。

####资源限制

XSI IPC都有内置限制(built-in limit),大多数可以通过重新配置内核而加以修改。在Linux下面我们可以通过ipcs -l来显示 先关的ipc限制，修改限制可以用过sysctl完成。

####优点和缺点

XSI IPC有下面这些问题。首先IPC结构没有引用计数，这就意味如果不显示调用的话那么资源会一直保留，即使没有人使用这个IPC的话也一直会存在于 系统中，直到显式现出内容和系统重启，或是通过外部命令ipcrm来删除。其次最重要的一点是，这个东西太像文件系统了， 整个Unix系统的理念就是所有对象都是文件，比如open,read,write,select,poll都是操作文件描述符的，甚至unix socket也统一到了 这个接口上，而ipc因为没有抽象导致需要提供一系列辅助的API来构建自己的体系。优点可能就是比较快吧，但是实测的时候 发现其他设施效率并不会很差，但是却有着一致的接口。在后面打算提供几种代替的方案来尽可能地不使用XSI IPC.

消息队列使用unix domain socket来代替。

信号量通过进程共享的pthread和共享内存代替(另外实现方式).信号量主要注重于同步，所以我们给出的方案也是注重于同步。

另外因为IPC是全局的并且没有引用计数，所以如果需要删除ipc的话那么必须使用外部命令ipcrm来删除。而ipcrm不允许批量删除所有的 IPC对象，所以我们需要下面辅助脚本实现

	#!/usr/bin/env python
	#coding:gbk 
	#Copyright (c) Baidu.com, Inc. All Rights Reserved 
	#author:zhangyan04(@baidu.com)
	
	import os
	data=filter(lambda x:x.strip(),os.popen('ipcs').read().split('\n'))
	mem=[]
	sem=[]
	msg=[]
	for x in data:
	    if(x.find('Shared Memory Segments')!=-1):
	        mode=mem
	    elif(x.find('Semaphore Arrays')!=-1):
	        mode=sem
	    elif(x.find('Message Queues')!=-1):
	        mode=msg
	    elif(x.startswith('key')):
	        continue
	    else:
	        (key,id,owner,perms,used,msgs)=x.split()
	        mode.append((key,id,owner,perms,used,msgs))
	for x in mem:
	    os.system('ipcrm -m %s'%(x[1]))
	for x in sem:
	    os.system('ipcrm -s %s'%(x[1]))
	for x in msg:
	    os.system('ipcrm -q %s'%(x[1]))

###消息队列

消息队列由内核来管理，每一个队列通过一个队列ID来识别(queue ID).每一个消息队列都有一个结构msgidds与其关联

	/* Structure of record for one message inside the kernel.
	   The type `struct msg' is opaque.  */
	struct msqid_ds
	{
	  struct ipc_perm msg_perm;     /* structure describing operation permission */
	  __time_t msg_stime;           /* time of last msgsnd command */
	  unsigned long int __unused1;
	  __time_t msg_rtime;           /* time of last msgrcv command */
	  unsigned long int __unused2;
	  __time_t msg_ctime;           /* time of last change */
	  unsigned long int __unused3;
	  unsigned long int __msg_cbytes; /* current number of bytes on queue */
	  msgqnum_t msg_qnum;           /* number of messages currently on queue */
	  msglen_t msg_qbytes;          /* max number of bytes allowed on queue */
	  __pid_t msg_lspid;            /* pid of last msgsnd() */
	  __pid_t msg_lrpid;            /* pid of last msgrcv() */
	  unsigned long int __unused4;
	  unsigned long int __unused5;
	};

通过这个结构我们可以看到消息队列记录了最后一次发送和接收消息时间以及当前有多少条消息和字节内容在消息队列中。

因为消息队列是由内核来管理的，所以就存在一定的限制，包括：

-	一次可发送最大消息的字节数目，linux2.4.22为8192
-	一个特定队列中最大字节数，即所有消息字节数之和，linux2.4.22为16384
-	系统中最大消息队列数，linux2.4.22为16

关于消息队列的API有下面这些：

	/* Message queue control operation.  */
	//cmd可以为IPC_STAT表示获取属性，IPC_SET表示设置属性，IPC_RMID表示删除消息队列
	extern int msgctl (int __msqid, int __cmd, struct msqid_ds *__buf) __THROW;
	
	/* Get messages queue.  */
	extern int msgget (key_t __key, int __msgflg) __THROW;
	
	/* Receive message from message queue.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern ssize_t msgrcv (int __msqid, void *__msgp, size_t __msgsz,
	                       long int __msgtyp, int __msgflg);
	
	/* Send message to message queue.
	
	   This function is a cancellation point and therefore not marked with
	   __THROW.  */
	extern int msgsnd (int __msqid, __const void *__msgp, size_t __msgsz,
	                   int __msgflg);
	
	
	//对于msgrcv和msgsnd里面的const void*结构应该如下：
	#ifdef __USE_GNU
	/* Template for struct to be used as argument for `msgsnd' and `msgrcv'.  */
	struct msgbuf
	  {
	    long int mtype;             /* type of received/sent message */
	    char mtext[1];              /* text of the message */
	  };
	#endif
	//其中mtext为悬挂字节

对于msgsnd来说，如果flag指定为IPCNOWAIT的话，那么如果消息列队已满的话，那么不会阻塞而是理解返回EAGAIN. 阻塞情况在下面情况会恢复：

-	消息队列有数据了。
-	消息队列删除了，返回错误EIDRM
-	发生信号中断而且没有自动重启，返回EINTR.

对于msgrcv来说，如果flag被指定为IPCNOWAIT的话，和msgsnd效果一样。如果flag指定为MSGNOERROR的话，如果 接收到的信息大于nbytes的话，那么信息被截断，如果没有设置的话那么会返回错误E2BIG.对于type参数来说：

-	type==0.消息队列第一个消息
-	type>0.消息队列第一个类型为type消息
-	type<0.返回消息队列中类型<abs(type)的消息，如果存在多个的话那么返回第一个类型最小的消息。

可以看到消息队列是基于消息并且由内核管理，那么不可避免需要设置一个消息上限。但是这个上限可能是不可移植的。 消息队列提供比较方便的功能一方面是信息的记录，另外一方面是消息的过滤，这点它的代替产物unix domain soket可能并没有直接提供， 但是可以在应用层面完成消息划分以及消息按照类型或者是id过滤。

	#include <unistd.h>
	#include <sys/msg.h>
	#include <cstdio>
	#include <cstring>
	
	struct message{
	    long int mtype;
	    char mtext[512];
	};
	int main(){
	    int msgid=msgget(IPC_PRIVATE,0666);
	    message snd;
	    snd.mtype=911;
	    strcpy(snd.mtext,"help");
	    if(msgsnd(msgid,&snd,5,0)==-1){
	        printf("msgsnd %m\n");
	        return -1;
	    }
	    struct msqid_ds ds;
	    if(msgctl(msgid,IPC_STAT,&ds)==-1){
	        printf("msgctl IPC_STAT %m\n");
	        return -1;
	    }
	    printf("current bytes:%d,current number:%d,max bytes:%d\n",
	           ds.__msg_cbytes,ds.msg_qnum,ds.msg_qbytes);
	    message rcv;
	    if(msgrcv(msgid,&rcv,512,910,IPC_NOWAIT)==-1){
	        printf("msgrcv1 %m\n");
	    }
	    if(msgrcv(msgid,&rcv,521,911,0)==-1){
	        printf("msgrcv2 %m\n");
	        return -1;
	    }
	    printf("%s\n",rcv.mtext);
	    if(msgctl(msgid,IPC_RMID,NULL)==-1){
	        printf("msgctl IPC_RMID %m\n");
	    }
	    return 0;    
	}
	[dirlt@localhost.localdomain]$ ./a.out 
	current bytes:5,current number:1,max bytes:16384
	msgrcv1 No message of desired type
	help

###信号量

信号量主要用于进行多进程之间同步的。通常来说针对资源的话，提供是类似于操作系统里面提到的PV操作。 不过XSI的信号量要复杂得多，XSI的信号量提供的是一个信号集合。对于每一个信号量集都下面这样的信息结构

	/* Data structure describing a set of semaphores.  */
	struct semid_ds
	{
	  struct ipc_perm sem_perm;             /* operation permission struct */
	  __time_t sem_otime;                   /* last semop() time */
	  unsigned long int __unused1;
	  __time_t sem_ctime;                   /* last time changed by semctl() */
	  unsigned long int __unused2;
	  unsigned long int sem_nsems;          /* number of semaphores in set */
	  unsigned long int __unused3;
	  unsigned long int __unused4;
	};

通常来说一个信号集包括下面这些属性：

-	信号集资源数目
-	最后操作这个信号集的pid
-	等待资源数目可用的进程数
-	等待资源数目==0的进程数(TODO(zhangyan04):什么应用场景)

可以看到下面提供的接口都可以获取或者是设置这个属性。

创建一个信号量集的话，可以使用下面这个接口：

	#include <sys/sem.h>
	int semget(key_t key,int nsems,int flag);

其中nsems表示想创建的信号量集合个数，而flag含义和消息队列一样允许IPCCREAT和IPCEXCL.低9位为权限。

控制这个信号集的话可以使用下面这个接口：

	#include <sys/sem.h>
	union semun{
	   int val;
	   struct semid_ds* buf;
	   unsigned short* array;
	};
	int semctl(int semid,int semnum,int cmd,...(union semun* arg));

semnum用于选定集合中某个特性的信号量，不同cmd情况下面可能不使用这个字段。cmd有下面这些选项：

	IPCSTAT 得到semidds信息
	IPCSET 设置semidds信息
	IPCRMID 删除这个信号量集
	GETVAL +semnum,+val得到某个信号量的资源个数
	SETVAL +semnum,+val设置某个信号量的资源个数
	GETPID +semnum,得到最后操作某个信号量的pid
	GETNCNT +semnum,得到等待资源的进程个数
	GETZCNT +semnum,得到等待资源==0的进程个数
	GETALL +array得到所有信号量的资源个数
	SETALL +array设置所有信号量的资源个数

最后一个接口是操作信号量集的接口。这个接口允许批量操作信号集并且以原子操作方式完成。

	#include <sys/sem.h>
	struct sembuf{
	    unsigned short sem_num; //number index in sem set
	    short sem_op; //>0 <0 ==0
	    short sem_flag; //IPC_NOWAIT,SEM_UNDO
	};
	int semop(int semid,struct sembuf semoparray[],size_t nops);

语义就是进行每个semoparry里面的操作，并且以原子方式操作。semnum表示我们操作第几个信号量。 这里需要解释一下semop和semflag.首先如果semflag指定为SEMUNDO的话，那么可以认为semop取了反就是， SEMUNDO的意思就是说撤销刚才的操作。

-	semop > 0,那么相当于释放资源
-	semop < 0,那么相当于获取资源
	-	如果资源充足的话，那么操作没有问题
	-	如果资源不充足但是设置了IPCNOWAIT的话，那么立即出错返回EAGAIN.
	-	如果资源不充足没有设置IPCNOTWAIT的话，等待资源进程个数+1,立即阻塞直到
		-	资源可用
		-	系统删除信号量，那么返回错误EIDRM
		-	信号中断返回EINTR,等待资源进程个数-1
-	semop==0,那么相当于等待信号量值变为0
	-	如果为0那么立即返回
	-	如果不为0并且设置IPCNOWAIT的话，那么立即出错返回EAGAIN.
	-	如果不为0并且没有设置IPCNOWAIT的话，那么等待资源==0的进程个数+1,立即阻塞直到
		-	资源个数==0
		-	系统删除信号量，返回错误EIDRM
		-	信号中断返回EINTR,等待资源==0的进程个数-1

其实信号量的接口还是非常易于理解的，但是却没有必要，很少有情况我们需要操作多个信号集。 下面一个通过信号量来同步父子进程的例子

	#include <unistd.h>
	#include <sys/sem.h>
	#include <sys/wait.h>
	#include <cstdio>
	#include <cstring>
	
	int main(){
	    int semid=semget(IPC_PRIVATE,1,0666);
	    int value=0;
	    semctl(semid,0,SETVAL,&value);
	
	    pid_t pid=fork();
	    if(pid==0){//child
	        struct sembuf buf;
	        buf.sem_num=0;
	        buf.sem_op=-1;
	        printf("child wait to exit\n");
	        semop(semid,&buf,1);
	        printf("child about to exit\n");
	        return 0;
	    }
	    sleep(2);
	    struct sembuf buf;
	    buf.sem_num=0;
	    buf.sem_op=1;
	    printf("tell child ready\n");
	    semop(semid,&buf,1);
	    wait(NULL);
	
	    //delete it
	    semctl(semid,0,IPC_RMID);
	    return 0;
	}
	[dirlt@localhost.localdomain]$ ./a.out 
	child wait to exit
	tell child ready
	child about to exit

###共享存储

共享存储也成为共享内存，和其他XSI IPC一样也每个共享存储段也有一个结构

	#include <sys/shm.h>
	/* Data structure describing a set of semaphores.  */
	struct shmid_ds
	  {
	    struct ipc_perm shm_perm;           /* operation permission struct */
	    size_t shm_segsz;                   /* size of segment in bytes */
	    __time_t shm_atime;                 /* time of last shmat() */
	    unsigned long int __unused1;
	    __time_t shm_dtime;                 /* time of last shmdt() */
	    unsigned long int __unused2;
	    __time_t shm_ctime;                 /* time of last change by shmctl() */
	    unsigned long int __unused3;
	    __pid_t shm_cpid;                   /* pid of creator */
	    __pid_t shm_lpid;                   /* pid of last shmop */
	    shmatt_t shm_nattch;                /* number of current attaches */
	    unsigned long int __unused4;
	    unsigned long int __unused5;
	  };

关于共享存储的接口如下：

	/* The following System V style IPC functions implement a shared memory
	   facility.  The definition is found in XPG4.2.  */
	
	/* Shared memory control operation.  */
	extern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) __THROW;
	
	/* Get shared memory segment.  */
	extern int shmget (key_t __key, size_t __size, int __shmflg) __THROW;
	
	/* Attach shared memory segment.  */
	extern void *shmat (int __shmid, __const void *__shmaddr, int __shmflg)
	     __THROW;
	
	/* Detach shared memory segment.  */
	extern int shmdt (__const void *__shmaddr) __THROW;

首先我们通过shmget来获得一个共享内存标识符，size这个字段表示共享存储大小内部会和PAGESIZE对齐。 然后调用shmctl来操作这个共享内存包括IPCSTAT,IPCSET以及IPCRMID.如果进程需要连接到这个共享内存段的话， 可以调用shmat,flag有下面这些选项：

-	SHMRND.如果addr不为0的话，那么会将addr向下取地址为SHMLBA的平方
-	SHMRDONLY.只读的共享内存段

如果不想连接这个共享内存段的话，那么可以直接shmdt.这个时候shmidds里面的shmnattch字段会-1.

相对来说，共享内存是最好理解的IPC了，是一种非常自然的概念。

	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/wait.h>
	#include <cstdio>
	#include <cstring>
	
	int main(){
	    printf("SHMLBA(shared memory low boundary):%d\n",SHMLBA);
	    int shmid=shmget(IPC_PRIVATE,1024,0666);
	    pid_t pid=fork();
	    if(pid==0){//child
	        sleep(2);
	        char* addr=(char*)shmat(shmid,0,0);
	        printf("%s\n",addr);
	        shmid_ds buf;
	        shmctl(shmid,IPC_STAT,&buf);
	        printf("segment size:%d,attach number:%d\n",buf.shm_segsz,buf.shm_nattch);
	        return 0;
	    }
	    char* addr=(char*)shmat(shmid,0,0);
	    strcpy(addr,"hello,world");
	    wait(NULL);
	    return 0;
	}
	[dirlt@localhost.localdomain]$ ./a.out 
	SHMLBA(shared memory low boundary):4096
	hello,world
	segment size:1024,attach number:2

###mmap共享内存

如果仅仅是父子进程之间的共享内存的话，那么可以有更加简单的方式，都和mmap相关。第一种方式是将 mmap映射/dev/zero这个文件。因为/dev/zero是一个特殊文件任何写都被忽略，并且一旦映射上的话存储 区内容都被初始化为0.另外一种方式是简化的方式，Linux系统提供了MAPANON选项使用这个选项的话，那么不需要 打开/dev/zero就可以创建一个具有进程关系之间的匿名存储映射。

	#include <unistd.h>
	#include <fcntl.h>
	#include <sys/types.h>
	#include <sys/mman.h>
	#include <sys/wait.h>
	#include <cstdio>
	#include <cstring>
	
	int main(){
	    int fd=open("/dev/zero",O_RDWR);
	    char* addr=(char*)mmap(0,1024,PROT_READ | PROT_WRITE,MAP_SHARED,fd,0);
	    close(fd);
	    if(fork()==0){//child
	        sleep(1);
	        printf("%s\n",addr);
	        munmap(addr,1024);
	        return 0;
	    }
	    strcpy(addr,"hello");
	    wait(NULL);
	    munmap(addr,1024);
	    return 0;
	}
	#include <unistd.h>
	#include <sys/mman.h>
	#include <sys/wait.h>
	#include <cstdio>
	#include <cstring>
	
	int main(){
	    char* addr=(char*)mmap(0,1024,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANON,-1,0);
	    if(fork()==0){//child
	        sleep(1);
	        printf("%s\n",addr);
	        munmap(addr,1024);
	        return 0;
	    }
	    strcpy(addr,"hello");
	    wait(NULL);
	    munmap(addr,1024);
	    return 0;
	}

使用mmap相对于使用IPC共享内存来说，使用更加方便简单，但是只允许是在有进程关系之间进程使用。

###进程pthread锁

pthread的同步机制允许设置进程之间的共享属性。通过pthread的同步机制是在共享内存上面开辟并且设置了共享属性， 那么就允许pthread来协调进程之间的同步。

	#include <unistd.h>
	#include <pthread.h>
	#include <sys/mman.h>
	#include <sys/wait.h>
	#include <cstdio>
	#include <cstring>
	
	int main(){
	    void* addr=(void*)mmap(0,1024,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANON,-1,0);
	    //在共享内存上面开辟出互斥锁和条件变量
	    pthread_mutexattr_t attr;
	    pthread_mutexattr_init(&attr);
	    pthread_mutexattr_setpshared(&attr,1);
	    pthread_mutex_t* mutex=(pthread_mutex_t*)addr;
	    pthread_mutex_init(mutex,&attr);
	
	    pthread_condattr_t attr2;
	    pthread_condattr_init(&attr2);
	    pthread_condattr_setpshared(&attr2,1);
	    pthread_cond_t* cond=(pthread_cond_t*)((char*)addr+sizeof(pthread_mutex_t));
	    pthread_cond_init(cond,&attr2);
	
	    if(fork()==0){//child
	        printf("child wait to exit\n");
	        pthread_cond_wait(cond,mutex);
	        printf("child about to exit\n");
	        munmap(addr,1024);
	        return 0;
	    }
	    sleep(1);
	    pthread_cond_signal(cond);
	    printf("parent waiting\n");
	    wait(NULL);
	    //fini，只允许在一个进程内销毁一次
	    int err=0;
	    err=pthread_mutex_destroy(mutex);
	    if(err!=0){
	        printf("mutex destroy:%s\n",strerror(err));
	    }
	    err=pthread_cond_destroy(cond);
	    if(err!=0){
	        printf("cond destroy:%s\n",strerror(err));
	    }
	    munmap(addr,1024);
	    return 0;
	}
	[dirlt@localhost.localdomain]$ ./a.out 
	child wait to exit
	parent waiting
	child about to exit